import pandas as pd
import csv
import os
from datetime import date, datetime, timedelta # Importamos timedelta para el límite de 7 días
from typing import Dict, Any, List
import uuid

# --- 1. DEFINICIÓN DE CONSTANTES (Nuestras "Tablas" Inmutables) ---

# ROL Y PERMISOS (Jerarquía)
ROLES_PERMISOS = {
    'ESTUDIANTE': {'ver_notas': True, 'llenar_campos': False, 'publicar_nota': False, 'editar_7dias': False, 'modificar_final': False, 'admin_usuarios': False, 'anular_alertas': False},
    'PROFESOR': {'ver_notas': True, 'llenar_campos': True, 'publicar_nota': True, 'editar_7dias': False, 'modificar_final': False, 'admin_usuarios': False, 'anular_alertas': False},
    'ADMINISTRACION': {'ver_notas': True, 'llenar_campos': False, 'publicar_nota': False, 'editar_7dias': False, 'modificar_final': False, 'admin_usuarios': True, 'anular_alertas': False},
    'ENCARGADA_REGISTRO': {'ver_notas': True, 'llenar_campos': False, 'publicar_nota': False, 'editar_7dias': True, 'modificar_final': True, 'admin_usuarios': False, 'anular_alertas': False}, # Le damos permiso de modificar la nota final (modificar_final)
    
	'DIRECTOR': {'ver_notas': True, 'llenar_campos': True, 'publicar_nota': True, 'editar_7dias': True, 'modificar_final': True, 'admin_usuarios': True, 'anular_alertas': True},
}


# PESOS DE CALIFICACIÓN (DEBE SUMAR 100)
PESOS_CALIFICACION = {
    'participacion': 20,    # Ponderación del 20%
    'cuaderno': 15,         # Ponderación del 15%
    'practica': 20,         # Ponderación del 20%
    'exposicion': 20,       # Ponderación del 20%
    'prueba_mensual': 25    # Ponderación del 25%


# ESCALA DE CALIFICACIONES (MINERD/USA)
ESCALA_LETRAS = {
    (97, 100): "A+", (93, 96): "A", (90, 92): "A-",
    (87, 89): "B+", (83, 86): "B", (80, 82): "B-",
    (77, 79): "C+", (73, 76): "C", (70, 72): "C-",
    (67, 69): "D+", (63, 66): "D", (60, 62): "D-",
    (0, 59): "F",
}

# --- 2. BASE DE DATOS SIMULADA (Uso de listas/diccionarios en memoria) ---

# ⚠️ NOTA: Usamos esta estructura simple en memoria hasta que implementemos la base de datos real.
USUARIOS_SIMULADOS = [
    {'usuario_ID': 1001, 'usuario_nombre': 'Ana', 'usuario_apellido': 'Bermudez', 'usuario_rol': 'ESTUDIANTE'},
    {'usuario_ID': 2005, 'usuario_nombre': 'Pedro', 'usuario_apellido': 'Gomez', 'usuario_rol': 'PROFESOR'},
    {'usuario_ID': 3001, 'usuario_nombre': 'Carmen', 'usuario_apellido': 'Duarte', 'usuario_rol': 'DIRECTOR'},
    {'usuario_ID': 4002, 'usuario_nombre': 'Raquel', 'usuario_apellido': 'Perez', 'usuario_rol': 'ADMINISTRACION'},
    {'usuario_ID': 5003, 'usuario_nombre': 'Jose', 'usuario_apellido': 'Martinez', 'usuario_rol': 'ENCARGADA_REGISTRO'},
]

REGISTROS_CALIFICACION_SIMULADOS List [Dict[ str, Any]] = []

# ------------------------------------------------------------------------
# F U N C I O N E S
# ------------------------------------------------------------------------

def gestionar_permisos(user_id: int) -> Dict[str, Any]:
    """
    Busca al usuario por ID, verifica su rol y retorna un diccionario
    con los datos del usuario y sus permisos asociados.
    """
    
    # BUCLE: Itera sobre la lista de usuarios simulados
    try:
        usuario_encontrado = None
        for usuario in USUARIOS_SIMULADOS:
            if usuario['usuario_ID'] == user_id:
                usuario_encontrado = usuario
                break
        
        # ESTRUCTURA DE CONTROL: Verifica si el usuario existe
        if usuario_encontrado:
            rol = usuario_encontrado['usuario_rol']
            
            # ESTRUCTURA DE CONTROL: Verifica si el rol existe en la tabla de permisos
            if rol in ROLES_PERMISOS:
                permisos = ROLES_PERMISOS[rol]\

		permisos_clean = {k: bool(v) for k, v in permisos.items()}
                
                # Combina los datos del usuario y sus permisos en un solo diccionario
                resultado = {
                    'autenticado': True,
                    'datos': usuario_encontrado,
                    'permisos': permisos
                }
                return resultado
            else:
                return {'autenticado': False, 'mensaje': f"Error: Rol '{rol}' no definido en el sistema de permisos."}
        else:
            return {'autenticado': False, 'mensaje': "Error: Usuario no encontrado."}
            
    # CONTROL DE ERRORES: Captura cualquier error inesperado (ej. KeyError, TypeError)
    except Exception as e:
        return {'autenticado': False, 'mensaje': f"Error interno al gestionar permisos: {e}"}

# --- PRUEBA (Opcional, no parte de la función final) ---
# director_permisos = gestionar_permisos(3001)
# print(director_permisos)
# estudiante_permisos = gestionar_permisos(1001)
# print(estudiante_permisos)
# error_permisos = gestionar_permisos(9999)
# print(error_permisos)



}


def obtener_calificacion_letras(nota_numerica: float) -> str:
    """
    Convierte una nota numérica (0-100) a la escala de letras MINERD/USA.
    Utiliza la constante ESCALA_LETRAS.
    """
    # BUCLE: Itera sobre los rangos de la ESCALA_LETRAS
    for (min_nota, max_nota), letra in ESCALA_LETRAS.items():
        # ESTRUCTURA DE CONTROL: Verifica si la nota cae dentro del rango
        if min_nota <= nota_numerica <= max_nota:
            return letra
    
    # ESTRUCTURA DE CONTROL: Caso de error (nunca debería ocurrir si ESCALA_LETRAS cubre 0-100)
    return "N/A"

def calcular_calificacion_periodo(campos_detallados: Dict[str, float]) -> Dict[str, Any]:
    """
    Suma las calificaciones de los campos detallados, calcula el promedio ponderado (0-100),
    y lo convierte a la escala de letras.
    """
    nota_final_numerica = 0
    
    # CONTROL DE ERRORES: Asegura que el diccionario de pesos exista
    if not PESOS_CALIFICACION:
         return {'error': True, 'mensaje': "Error: La constante PESOS_CALIFICACION no está definida."}

    # BUCLE: Itera sobre los campos detallados para calcular la nota ponderada
    try:
        for campo, puntuacion_obtenida in campos_detallados.items():
            peso_campo = PESOS_CALIFICACION.get(campo)
            
            # ESTRUCTURA DE CONTROL: Verifica que el campo de calificación tenga un peso definido
            if peso_campo is None:
                raise ValueError(f"Campo '{campo}' no tiene un peso definido en PESOS_CALIFICACION.")
            
            # Cálculo Ponderado: (Puntuación obtenida / 100) * Peso
            # Asumimos que la puntuación de cada campo es sobre 100 (o su equivalente),
            # pero aquí calcularemos la contribución directa a la nota final (que es sobre 100).
            # Para la simplicidad del cálculo, asumiremos que los 'campos_detallados'
            # ya contienen el puntaje que contribuye directamente al 100% final.
            # *Nota*: Se deben asegurar que los campos que llena el profesor sumen 100.
            
            nota_final_numerica += puntuacion_obtenida
        
        # Redondear el resultado a dos decimales
        nota_final_numerica = round(nota_final_numerica, 2)
        
        # ESTRUCTURA DE CONTROL: Limitar la nota a 100
        if nota_final_numerica > 100:
             nota_final_numerica = 100.0

        nota_final_letras = obtener_calificacion_letras(nota_final_numerica)
        
        return {
            'error': False,
            'calificacion_numerica': nota_final_numerica,
            'calificacion_letras': nota_final_letras
        }
    
    # CONTROL DE ERRORES: Captura errores durante el cálculo (ej. si la puntuación no es un número)
    except (ValueError, TypeError) as e:
        return {'error': True, 'mensaje': f"Error de cálculo. Verifique los tipos de datos: {e}"}
    except Exception as e:
         return {'error': True, 'mensaje': f"Error inesperado al calcular la calificación: {e}"}

#crear y actualizar registro

def crear_o_actualizar_registro(
    profesor_id: int, 
    estudiante_id: int, 
    materia: str, 
    periodo_num: int, 
    campos: Dict[str, float],
    metodologia: str
) -> Dict[str, Any]:
    """
    Bloque 3: Simula la inserción o actualización de un registro de calificación
    en la base de datos, aplicando permisos y reglas de inmutabilidad.
    """
    
    # 1. VERIFICACIÓN DE PERMISOS
    permisos_data = gestionar_permisos(profesor_id)
    # ESTRUCTURA DE CONTROL: Verifica si el usuario tiene permiso para llenar campos
    if not permisos_data['autenticado'] or not permisos_data['permisos'].get('llenar_campos'):
        return {'exito': False, 'mensaje': 'Permiso denegado: El usuario no puede llenar campos de calificación.'}
        
    # 2. CÁLCULO DE LA NOTA
    # CONTROL DE ERRORES: Intenta calcular la nota
    calculo_resultado = calcular_calificacion_periodo(campos)

    if calculo_resultado['error']:
        return {'exito': False, 'mensaje': f"Fallo en el cálculo: {calculo_resultado['mensaje']}"}

    nota_numerica = calculo_resultado['calificacion_numerica']
    nota_letras = calculo_resultado['calificacion_letras']

    # 3. BÚSQUEDA DEL REGISTRO EXISTENTE
    registro_existente = None
    indice_registro = -1
    
    # BUCLE: Busca si ya existe un registro único (Estudiante-Materia-Período)
    for i, registro in enumerate(REGISTROS_CALIFICACION_SIMULADOS):
        if (registro['estudiante_ID'] == estudiante_id and 
            registro['materia'] == materia and 
            registro['periodo_numero'] == periodo_num):
            registro_existente = registro
            indice_registro = i
            break
            
    # 4. APLICACIÓN DE REGLAS DE EDICIÓN
    
    # ESTRUCTURA DE CONTROL: Regla de inmutabilidad/publicación
    if registro_existente and registro_existente['publicado']:
        
        fecha_limite_str = registro_existente.get('fecha_limite_modificacion')
        fecha_limite = datetime.strptime(fecha_limite_str, '%Y-%m-%d').date()
        fecha_actual = date.today()
        
        # ESTRUCTURA DE CONTROL: Verifica si se excedió el límite de 7 días
        if fecha_actual > fecha_limite:
            # ESTRUCTURA DE CONTROL: Solo el Director o Encargada de Registro pueden modificar después del límite
            permiso_modificar_tardio = permisos_data['permisos'].get('modificar_final') or permisos_data['permisos'].get('editar_7dias')
            if not permiso_modificar_tardio:
                 return {'exito': False, 'mensaje': 'Edición Bloqueada: El registro está publicado y ha excedido la fecha límite de modificación.'}
        
    # 5. CREACIÓN O ACTUALIZACIÓN DEL DOCUMENTO
    fecha_hoy = date.today()
    fecha_publicacion_str = fecha_hoy.strftime('%Y-%m-%d')
    fecha_limite_modificacion_str = (fecha_hoy + timedelta(days=7)).strftime('%Y-%m-%d')
    
    nuevo_registro = {
        'estudiante_ID': estudiante_id,
        'profesor_ID': profesor_id,
        'materia': materia,
        'periodo_numero': periodo_num,
        'campos_detallados': campos,
        'calificacion_numerica': nota_numerica, 
        'calificacion_letras': nota_letras,
        'promedio_general': None,
        'metodologia_docente': metodologia,
        'fecha_publicacion': fecha_publicacion_str,
        'publicado': False, # Por defecto, la edición es NO publicada
        'alerta_activa': True,
        'fecha_limite_modificacion': fecha_limite_modificacion_str,
        'apelaciones_activas': []
    }

    # ESTRUCTURA DE CONTROL: Determina si es una creación o una actualización
    if registro_existente:
        # Actualización
        REGISTROS_CALIFICACION_SIMULADOS[indice_registro].update(nuevo_registro)
        # Asegura que el ID original se mantenga
        registro_id_final = registro_existente['registro_ID']
        REGISTROS_CALIFICACION_SIMULADOS[indice_registro]['registro_ID'] = registro_id_final 
        
        # RETORNO CORREGIDO: Incluye el 'registro_ID'
        return {
            'exito': True, 
            'mensaje': f'Registro {registro_id_final} actualizado exitosamente. Nota actual: {nota_numerica}',
            'registro_ID': registro_id_final 
        }
    else:
        # Creación
        registro_id_final = str(uuid.uuid4()) # ID único y corto
        nuevo_registro['registro_ID'] = registro_id_final
        REGISTROS_CALIFICACION_SIMULADOS.append(nuevo_registro)
        
        # RETORNO CORREGIDO: Incluye el 'registro_ID'
        return {
            'exito': True, 
            'mensaje': f'Nuevo registro {registro_id_final} creado exitosamente. Nota: {nota_numerica}',
            'registro_ID': registro_id_final
        }

def publicar_registro_calificacion(
    user_id_publicador: int, 
    registro_id: str, 
) -> Dict[str, Any]:
    """
    Bloque 4: Publica oficialmente un registro de calificación. 
    Esto congela el registro para edición futura, aplicando la regla de 7 días 
    para la modificación ordinaria.
    """
    
    # 1. VERIFICACIÓN DE PERMISOS
    permisos_data = gestionar_permisos(user_id_publicador)
    
    # ESTRUCTURA DE CONTROL: Verifica si el usuario está autenticado y tiene permiso para publicar
    if not permisos_data['autenticado'] or not permisos_data['permisos'].get('publicar_nota'):
        return {'exito': False, 'mensaje': 'Permiso denegado: El usuario no tiene permiso para publicar calificaciones.'}
        
    # 2. BÚSQUEDA DEL REGISTRO
    registro_encontrado = None
    indice_registro = -1
    
    # BUCLE: Busca el registro por su ID único
    for i, registro in enumerate(REGISTROS_CALIFICACION_SIMULADOS):
        if registro['registro_ID'] == registro_id:
            registro_encontrado = registro
            indice_registro = i
            break
            
    # ESTRUCTURA DE CONTROL: Verifica si el registro existe
    if not registro_encontrado:
        return {'exito': False, 'mensaje': f'Error: Registro con ID {registro_id} no encontrado.'}
        
    # 3. VERIFICACIÓN DE ESTADO ACTUAL
    # ESTRUCTURA DE CONTROL: Verifica si ya está publicado
    if registro_encontrado['publicado']:
         return {'exito': False, 'mensaje': 'El registro ya se encuentra publicado y validado.'}
         
    # 4. APLICACIÓN DE LA PUBLICACIÓN
    
    # CONTROL DE ERRORES: Manejo de la actualización en memoria
    try:
        # La publicación oficial es HOY, y la fecha límite de edición es HOY + 7 días.
        fecha_hoy = date.today().strftime('%Y-%m-%d')
        fecha_limite = (date.today() + timedelta(days=7)).strftime('%Y-%m-%d')
        
        # Actualiza el estado del registro
        REGISTROS_CALIFICACION_SIMULADOS[indice_registro].update({
            'publicado': True,
            'alerta_activa': False, # Se asume que la publicación resuelve la alerta
            'fecha_publicacion': fecha_hoy,
            'fecha_limite_modificacion': fecha_limite
        })

        return {'exito': True, 'mensaje': f'Registro {registro_id} publicado exitosamente. Se ha activado la ventana de edición de 7 días (hasta {fecha_limite}).'}
    
    except Exception as e:
        # CONTROL DE ERRORES: Captura cualquier error durante el proceso de actualización
        return {'exito': False, 'mensaje': f'Error interno al actualizar el estado del registro: {e}'}

def crear_apelacion(estudiante_id: int, registro_id: str, comentario: str) -> Dict[str, Any]:
    """
    Permite a un estudiante crear una apelación sobre un registro de calificación publicado.
    """
    permisos_data = gestionar_permisos(estudiante_id)
    if not permisos_data['autenticado'] or permisos_data['datos']['usuario_rol'] != 'ESTUDIANTE':
        return {'exito': False, 'mensaje': "Permiso denegado: Solo los estudiantes autenticados pueden crear apelaciones."}

    registro_encontrado = None 
    indice_registro = -1

    for i, registro in enumerate(REGISTROS_CALIFICACION_SIMULADOS):
        if registro['registro_ID'] == registro_id:
            registro_encontrado = registro
            indice_registro = i 
            break
            
    if not registro_encontrado:
        return {'exito': False, 'mensaje': 'El registro no se encuentra.'}
        
    if not registro_encontrado.get('publicado'):
        return {'exito': False, 'mensaje': 'Solo se pueden apelar registros que han sido publicados.'}
        
    # Validar que el registro pertenezca a este estudiante
    if registro_encontrado['estudiante_ID'] != estudiante_id:
        return {'exito': False, 'mensaje': 'Acceso denegado: No puede apelar un registro que no es suyo.'}
        
    try:
        nueva_apelacion = {
            'apelacion_id': str(uuid.uuid4()),
            'estudiante_id': estudiante_id,
            'fecha_creacion': date.today().strftime('%Y-%m-%d'),
            'comentario': comentario,
            'estado': 'Pendiente', # Estados posibles: Pendiente, Aceptada, Rechazada
            'respuesta_admin': None
        }
        
        # Agregar la nueva apelación a la lista de apelaciones activas
        REGISTROS_CALIFICACION_SIMULADOS[indice_registro]['apelaciones_activas'].append(nueva_apelacion)
        
        return {
            'exito': True, 
            'mensaje': f'Apelación creada exitosamente para el registro {registro_id}. Estado: Pendiente.'
        }
        
    except Exception as e:
        return {'exito': False, 'mensaje': f"Error interno al crear la apelación: {e}"}

#bloque 6

def gestionar_apelacion_admin(user_id_admin: int, registro_id: str, apelacion_id: str, nuevo_estado: str, respuesta_admin: str) -> Dict[str, Any]:
    """
    Permite a un rol con permisos administrativos (ADMINISTRACION o DIRECTOR)
    cambiar el estado de una apelación a 'Aceptada' o 'Rechazada'.
    
    Si se acepta, se notifica al profesor y se podría activar una alerta 
    para forzar la revisión/edición de la nota.
    """
    
    permisos_data = gestionar_permisos(user_id_admin)
    # Requerimos el permiso admin_usuarios o modificar_final para esta acción de supervisión
    permiso_gestion = permisos_data['permisos'].get('admin_usuarios') or permisos_data['permisos'].get('modificar_final')

    if not permisos_data['autenticado'] or not permiso_gestion:
        return {'exito': False, 'mensaje': "Permiso denegado: Solo roles administrativos o con permisos de modificación final pueden gestionar apelaciones."}

    # 1. Encontrar el Registro
    registro_encontrado = None 
    indice_registro = -1

    for i, registro in enumerate(REGISTROS_CALIFICACION_SIMULADOS):
        if registro['registro_ID'] == registro_id:
            registro_encontrado = registro
            indice_registro = i 
            break
            
    if not registro_encontrado:
        return {'exito': False, 'mensaje': 'Error: El registro de calificación no se encuentra.'}
        
    # 2. Encontrar la Apelación
    apelacion_encontrada = None
    indice_apelacion = -1
    
    for j, apelacion in enumerate(registro_encontrado.get('apelaciones_activas', [])):
        if apelacion['apelacion_id'] == apelacion_id:
            apelacion_encontrada = apelacion
            indice_apelacion = j
            break
            
    if not apelacion_encontrada:
        return {'exito': False, 'mensaje': 'Error: La apelación con ese ID no se encontró en el registro especificado.'}
        
    # 3. Validar y Actualizar Estado
    estado_valido = nuevo_estado in ['Aceptada', 'Rechazada']
    if not estado_valido:
        return {'exito': False, 'mensaje': "Error: El nuevo estado debe ser 'Aceptada' o 'Rechazada'."}
        
    try:
        # Actualizar la apelación dentro del registro
        REGISTROS_CALIFICACION_SIMULADOS[indice_registro]['apelaciones_activas'][indice_apelacion]['estado'] = nuevo_estado
        REGISTROS_CALIFICACION_SIMULADOS[indice_registro]['apelaciones_activas'][indice_apelacion]['respuesta_admin'] = respuesta_admin
        
        mensaje_adicional = ""
        # 4. Lógica post-aceptación
        if nuevo_estado == 'Aceptada':
            # Se puede re-activar una alerta para forzar al profesor a revisar
            # Aunque el registro siga publicado, esto sirve como flag interno.
            REGISTROS_CALIFICACION_SIMULADOS[indice_registro]['alerta_activa'] = True
            mensaje_adicional = " Se ha re-activado la alerta del registro para revisión por parte del profesor."

        return {
            'exito': True, 
            'mensaje': f"Apelación {apelacion_id} ha sido marcada como '{nuevo_estado}' por el usuario {user_id_admin}.{mensaje_adicional}"
        }
        
    except Exception as e:
        return {'exito': False, 'mensaje': f"Error interno al gestionar la apelación: {e}"}
























