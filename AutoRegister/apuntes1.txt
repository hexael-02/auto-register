import pandas as pd
import csv
import os
from datetime import date, datetime, timedelta # Importamos timedelta para el límite de 7 días
from typing import Dict, Any, List
import uuid

# --- 1. DEFINICIÓN DE CONSTANTES (Nuestras "Tablas" Inmutables) ---

# ROL Y PERMISOS (Jerarquía)
ROLES_PERMISOS = {
    'ESTUDIANTE': {'ver_notas': True, 'llenar_campos': False, 'publicar_nota': False, 'editar_7dias': False, 'modificar_final': False, 'admin_usuarios': False, 'anular_alertas': False},
    'PROFESOR': {'ver_notas': True, 'llenar_campos': True, 'publicar_nota': True, 'editar_7dias': False, 'modificar_final': False, 'admin_usuarios': False, 'anular_alertas': False},
    'ADMINISTRACION': {'ver_notas': True, 'llenar_campos': False, 'publicar_nota': False, 'editar_7dias': False, 'modificar_final': False, 'admin_usuarios': True, 'anular_alertas': False},
    'ENCARGADA_REGISTRO': {'ver_notas': True, 'llenar_campos': False, 'publicar_nota': False, 'editar_7dias': True, 'modificar_final': True, 'admin_usuarios': False, 'anular_alertas': False}, # Le damos permiso de modificar la nota final (modificar_final)
    
	'DIRECTOR': {'ver_notas': True, 'llenar_campos': True, 'publicar_nota': True, 'editar_7dias': True, 'modificar_final': True, 'admin_usuarios': True, 'anular_alertas': True},
}


# PESOS DE CALIFICACIÓN (DEBE SUMAR 100)
PESOS_CALIFICACION = {
    'participacion': 20,    # Ponderación del 20%
    'cuaderno': 15,         # Ponderación del 15%
    'practica': 20,         # Ponderación del 20%
    'exposicion': 20,       # Ponderación del 20%
    'prueba_mensual': 25    # Ponderación del 25%


# ESCALA DE CALIFICACIONES (MINERD/USA)
ESCALA_LETRAS = {
    (97, 100): "A+", (93, 96): "A", (90, 92): "A-",
    (87, 89): "B+", (83, 86): "B", (80, 82): "B-",
    (77, 79): "C+", (73, 76): "C", (70, 72): "C-",
    (67, 69): "D+", (63, 66): "D", (60, 62): "D-",
    (0, 59): "F",
}

# --- 2. BASE DE DATOS SIMULADA (Uso de listas/diccionarios en memoria) ---

# ⚠️ NOTA: Usamos esta estructura simple en memoria hasta que implementemos la base de datos real.
USUARIOS_SIMULADOS = [
    {'usuario_ID': 1001, 'usuario_nombre': 'Ana', 'usuario_apellido': 'Bermudez', 'usuario_rol': 'ESTUDIANTE'},
    {'usuario_ID': 2005, 'usuario_nombre': 'Pedro', 'usuario_apellido': 'Gomez', 'usuario_rol': 'PROFESOR'},
    {'usuario_ID': 3001, 'usuario_nombre': 'Carmen', 'usuario_apellido': 'Duarte', 'usuario_rol': 'DIRECTOR'},
    {'usuario_ID': 4002, 'usuario_nombre': 'Raquel', 'usuario_apellido': 'Perez', 'usuario_rol': 'ADMINISTRACION'},
    {'usuario_ID': 5003, 'usuario_nombre': 'Jose', 'usuario_apellido': 'Martinez', 'usuario_rol': 'ENCARGADA_REGISTRO'},
]

REGISTROS_CALIFICACION_SIMULADOS List [Dict[ str, Any]] = []

# ------------------------------------------------------------------------
# F U N C I O N E S
# ------------------------------------------------------------------------

def gestionar_permisos(user_id: int) -> Dict[str, Any]:
    """
    Busca al usuario por ID, verifica su rol y retorna un diccionario
    con los datos del usuario y sus permisos asociados.
    """
    
    # BUCLE: Itera sobre la lista de usuarios simulados
    try:
        usuario_encontrado = None
        for usuario in USUARIOS_SIMULADOS:
            if usuario['usuario_ID'] == user_id:
                usuario_encontrado = usuario
                break
        
        # ESTRUCTURA DE CONTROL: Verifica si el usuario existe
        if usuario_encontrado:
            rol = usuario_encontrado['usuario_rol']
            
            # ESTRUCTURA DE CONTROL: Verifica si el rol existe en la tabla de permisos
            if rol in ROLES_PERMISOS:
                permisos = ROLES_PERMISOS[rol]
                
                # Combina los datos del usuario y sus permisos en un solo diccionario
                resultado = {
                    'autenticado': True,
                    'datos': usuario_encontrado,
                    'permisos': permisos
                }
                return resultado
            else:
                return {'autenticado': False, 'mensaje': f"Error: Rol '{rol}' no definido en el sistema de permisos."}
        else:
            return {'autenticado': False, 'mensaje': "Error: Usuario no encontrado."}
            
    # CONTROL DE ERRORES: Captura cualquier error inesperado (ej. KeyError, TypeError)
    except Exception as e:
        return {'autenticado': False, 'mensaje': f"Error interno al gestionar permisos: {e}"}

# --- PRUEBA (Opcional, no parte de la función final) ---
# director_permisos = gestionar_permisos(3001)
# print(director_permisos)
# estudiante_permisos = gestionar_permisos(1001)
# print(estudiante_permisos)
# error_permisos = gestionar_permisos(9999)
# print(error_permisos)



}


def obtener_calificacion_letras(nota_numerica: float) -> str:
    """
    Convierte una nota numérica (0-100) a la escala de letras MINERD/USA.
    Utiliza la constante ESCALA_LETRAS.
    """
    # BUCLE: Itera sobre los rangos de la ESCALA_LETRAS
    for (min_nota, max_nota), letra in ESCALA_LETRAS.items():
        # ESTRUCTURA DE CONTROL: Verifica si la nota cae dentro del rango
        if min_nota <= nota_numerica <= max_nota:
            return letra
    
    # ESTRUCTURA DE CONTROL: Caso de error (nunca debería ocurrir si ESCALA_LETRAS cubre 0-100)
    return "N/A"

def calcular_calificacion_periodo(campos_detallados: Dict[str, float]) -> Dict[str, Any]:
    """
    Suma las calificaciones de los campos detallados, calcula el promedio ponderado (0-100),
    y lo convierte a la escala de letras.
    """
    nota_final_numerica = 0
    
    # CONTROL DE ERRORES: Asegura que el diccionario de pesos exista
    if not PESOS_CALIFICACION:
         return {'error': True, 'mensaje': "Error: La constante PESOS_CALIFICACION no está definida."}

    # BUCLE: Itera sobre los campos detallados para calcular la nota ponderada
    try:
        for campo, puntuacion_obtenida in campos_detallados.items():
            peso_campo = PESOS_CALIFICACION.get(campo)
            
            # ESTRUCTURA DE CONTROL: Verifica que el campo de calificación tenga un peso definido
            if peso_campo is None:
                raise ValueError(f"Campo '{campo}' no tiene un peso definido en PESOS_CALIFICACION.")
            
            # Cálculo Ponderado: (Puntuación obtenida / 100) * Peso
            # Asumimos que la puntuación de cada campo es sobre 100 (o su equivalente),
            # pero aquí calcularemos la contribución directa a la nota final (que es sobre 100).
            # Para la simplicidad del cálculo, asumiremos que los 'campos_detallados'
            # ya contienen el puntaje que contribuye directamente al 100% final.
            # *Nota*: Se deben asegurar que los campos que llena el profesor sumen 100.
            
            nota_final_numerica += puntuacion_obtenida
        
        # Redondear el resultado a dos decimales
        nota_final_numerica = round(nota_final_numerica, 2)
        
        # ESTRUCTURA DE CONTROL: Limitar la nota a 100
        if nota_final_numerica > 100:
             nota_final_numerica = 100.0

        nota_final_letras = obtener_calificacion_letras(nota_final_numerica)
        
        return {
            'error': False,
            'calificacion_numerica': nota_final_numerica,
            'calificacion_letras': nota_final_letras
        }
    
    # CONTROL DE ERRORES: Captura errores durante el cálculo (ej. si la puntuación no es un número)
    except (ValueError, TypeError) as e:
        return {'error': True, 'mensaje': f"Error de cálculo. Verifique los tipos de datos: {e}"}
    except Exception as e:
         return {'error': True, 'mensaje': f"Error inesperado al calcular la calificación: {e}"}

#crear y actualizar registro

def crear_o_actualizar_registro(
    profesor_id: int, 
    estudiante_id: int, 
    materia: str, 
    periodo_num: int, 
    campos: Dict[str, float],
    metodologia: str
) -> Dict[str, Any]:
    """
    Bloque 3: Simula la inserción o actualización de un registro de calificación
    en la base de datos, aplicando todas las reglas de negocio (permisos, publicación, fechas).
    """
    # 1. VERIFICACIÓN DE PERMISOS
    permisos_data = gestionar_permisos(profesor_id)
    # ESTRUCTURA DE CONTROL: Verifica si el profesor está autenticado y tiene permiso para llenar campos
    if not permisos_data['autenticado'] or not permisos_data['permisos'].get('llenar_campos'):
        return {'exito': False, 'mensaje': 'Permiso denegado: El usuario no puede llenar campos de calificación.'}
        
    # 2. CÁLCULO DE LA NOTA
    # CONTROL DE ERRORES: Intenta calcular la nota para evitar guardar datos incorrectos
    calculo_resultado = calcular_calificacion_periodo(campos)

    if calculo_resultado['error']:
        return {'exito': False, 'mensaje': f"Fallo en el cálculo: {calculo_resultado['mensaje']}"}

    nota_numerica = calculo_resultado['calificacion_numerica']
    nota_letras = calculo_resultado['calificacion_letras']

    # 3. BÚSQUEDA DEL REGISTRO EXISTENTE
    registro_existente = None
    indice_registro = -1
    
    # BUCLE: Busca si ya existe un registro para este Estudiante-Materia-Período
    for i, registro in enumerate(REGISTROS_CALIFICACION_SIMULADOS):
        if (registro['estudiante_ID'] == estudiante_id and 
            registro['materia'] == materia and 
            registro['periodo_numero'] == periodo_num):
            registro_existente = registro
            indice_registro = i
            break
            
    # 4. APLICACIÓN DE REGLAS DE EDICIÓN
    
    # ESTRUCTURA DE CONTROL: Regla de inmutabilidad/publicación
    if registro_existente and registro_existente['publicado']:
        
        fecha_limite_str = registro_existente.get('fecha_limite_modificacion')
        fecha_limite = datetime.strptime(fecha_limite_str, '%Y-%m-%d').date()
        fecha_actual = date.today()
        
        # ESTRUCTURA DE CONTROL: Verifica si se excedió el límite de 7 días
        if fecha_actual > fecha_limite:
            # ESTRUCTURA DE CONTROL: Solo el Director o Encargada de Registro puede modificar después del límite
            if not (permisos_data['permisos'].get('modificar_final') or permisos_data['permisos'].get('editar_7dias')):
                 return {'exito': False, 'mensaje': 'Edición Bloqueada: El registro está publicado y ha excedido la fecha límite de modificación.'}
        
    # 5. CREACIÓN O ACTUALIZACIÓN DEL DOCUMENTO
    fecha_publicacion = date.today().strftime('%Y-%m-%d')
    fecha_limite_modificacion = (date.today() + timedelta(days=7)).strftime('%Y-%m-%d')
    
    # Estructura del nuevo/actualizado registro (basado en el modelo REGISTRO_CALIFICACION)
    nuevo_registro = {
        'estudiante_ID': estudiante_id,
        'profesor_ID': profesor_id,
        'materia': materia,
        'periodo_numero': periodo_num,
        
        'campos_detallados': campos,
        'calificacion_numerica': nota_numerica,
        'calificacion_letras': nota_letras,
        'promedio_general': None, # Se llena al final del año
        
        'metodologia_docente': metodologia,
        'fecha_publicacion': fecha_publicacion,
        'publicado': False, # Siempre se crea/edita como NO publicado por defecto
        'alerta_activa': True, # Se asume activo hasta que el profesor PUBLIQUE
        'fecha_limite_modificacion': fecha_limite_modificacion,
        'apelaciones_activas': []
    }

    # ESTRUCTURA DE CONTROL: Determina si es una creación o una actualización
    if registro_existente:
        # Actualización
        REGISTROS_CALIFICACION_SIMULADOS[indice_registro].update(nuevo_registro)
        # Mantener el ID original si es una actualización
        REGISTROS_CALIFICACION_SIMULADOS[indice_registro]['registro_ID'] = registro_existente['registro_ID'] 
        return {'exito': True, 'mensaje': f'Registro {registro_existente["registro_ID"]} actualizado exitosamente.'}
    else:
        # Creación (genera un nuevo ID)
        nuevo_registro['registro_ID'] = str(uuid.uuid4()) # ID único y corto
        REGISTROS_CALIFICACION_SIMULADOS.append(nuevo_registro)
        return {'exito': True, 'mensaje': f'Nuevo registro {nuevo_registro["registro_ID"]} creado exitosamente.'}


























