# Sistema de Gesti√≥n y Registro de Calificaciones MINERD - Versi√≥n 1.0
# Desarrollado para demostrar la persistencia y el flujo de datos.
# Este archivo contiene 830 l√≠neas para una explicaci√≥n exhaustiva.

# --- 1. Importaciones de Librer√≠as --- (L√≠neas 6-12)
import pandas as pd              # L√≠nea 6: Para manejar datos como una hoja de c√°lculo (Excel).
import csv                       # L√≠nea 7: Para leer y escribir archivos CSV (texto con datos separados por comas).
import os                        # L√≠nea 8: Para interactuar con el sistema (ej. verificar si un archivo existe).
import json                      # L√≠nea 9: Para guardar estructuras complejas (como diccionarios) dentro del CSV.
import hashlib                   # L√≠nea 10: Para generar identificadores √∫nicos y cortos (huellas digitales de datos).
from datetime import date, datetime, timedelta # L√≠nea 11: Para trabajar con fechas y horas (fechas de ingreso, plazos).
import time                      # L√≠nea 12: Para pausas en el men√∫ y simular procesos (pausa de 1 segundo).

# --- 2. Configuraci√≥n y Constantes Globales --- (L√≠neas 14-61)

ARCHIVO_CSV = "minerd_calificaciones.csv" # L√≠nea 14: Nombre del archivo principal que guarda todas las notas.
ID_COUNTER_FILE = "minerd_id_counter.txt" # L√≠nea 15: Archivo para guardar el √∫ltimo n√∫mero de ID de registro.
ESTADO_INICIAL_NOTA = "N/A"      # L√≠nea 16: Valor por defecto para notas que a√∫n no se han llenado.
PLAZO_REVISION_DIAS = 5          # L√≠nea 17: Constante que define el plazo de 5 d√≠as para solicitar revisi√≥n.

# Estructura del DataFrame (Nombres de las columnas de nuestra hoja de c√°lculo)
COLUMNS = [                      # L√≠nea 20: Inicio de la lista de columnas.
    'ID_REGISTRO',               # L√≠nea 21: Identificador √∫nico de esta fila (la huella digital de la nota).
    'profesor_ID',               # L√≠nea 22: Qui√©n puso la nota.
    'estudiante_ID',             # L√≠nea 23: A qui√©n pertenece la nota.
    'periodo',                   # L√≠nea 24: Periodo escolar (ej. P1, P2, P3).
    'asignatura',                # L√≠nea 25: Materia o clase (ej. Matem√°ticas, Lengua).
    'fecha_ingreso',             # L√≠nea 26: Cu√°ndo se carg√≥ esta nota por √∫ltima vez.
    'estado_publicacion',        # L√≠nea 27: ¬øEs visible para el estudiante? (True/False).
    'P_PARTICIPACION',           # L√≠nea 28: Nota de Participaci√≥n.
    'P_PROYECTO',                # L√≠nea 29: Nota de Proyecto.
    'P_TAREA',                   # L√≠nea 30: Nota de Tarea.
    'P_EXAMEN',                  # L√≠nea 31: Nota de Examen.
    'P_NOTA_FINAL',              # L√≠nea 32: La nota final calculada (num√©rica).
    'P_LETRA_FINAL',             # L√≠nea 33: La nota final en letra (A, B, C, F).
    'P_DETALLES_JSON',           # L√≠nea 34: Informaci√≥n extra (como notas parciales de un proyecto) guardada en texto JSON.
    'estado_revision'            # L√≠nea 35: ¬øEl estudiante solicit√≥ que se revise esta nota? (True/False).
]                                # L√≠nea 36: Fin de la lista de columnas.

# Pesos y escala de calificaci√≥n (Los porcentajes que vale cada parte)
PESOS_CALIFICACION = {           # L√≠nea 39: Inicio del diccionario de pesos.
    'P_PARTICIPACION': 0.15,     # L√≠nea 40: Participaci√≥n vale 15% del total.
    'P_PROYECTO': 0.35,          # L√≠nea 41: Proyecto vale 35% del total.
    'P_TAREA': 0.25,             # L√≠nea 42: Tarea vale 25% del total.
    'P_EXAMEN': 0.25,            # L√≠nea 43: Examen vale 25% del total.
}                                # L√≠nea 44: Fin del diccionario de pesos.

CALIFICACION_CAMPOS = list(PESOS_CALIFICACION.keys()) # L√≠nea 46: Una lista sencilla con los nombres de las categor√≠as de notas (Participaci√≥n, Proyecto, etc.).

# Escala num√©rica a letra (Importante: se revisa de mayor a menor)
ESCALA_CALIFICACION = {          # L√≠nea 49: Inicio del diccionario de la escala de letras.
    90: 'A',                     # L√≠nea 50: 90 o m√°s es una 'A'.
    80: 'B',                     # L√≠nea 51: 80 a 89.99 es una 'B'.
    70: 'C',                     # L√≠nea 52: 70 a 79.99 es una 'C'.
    60: 'D',                     # L√≠nea 53: 60 a 69.99 es una 'D'.
    0: 'F'                       # L√≠nea 54: Menos de 60 es una 'F' (Fallo).
}                                # L√≠nea 55: Fin del diccionario de escala.

# Roles del sistema (Qui√©n puede hacer qu√©)
ROLES = {                        # L√≠nea 58: Inicio del diccionario de roles.
    'DIRECTOR': 'Director/a',    # L√≠nea 59: Rol de Director.
    'PROFESOR': 'Profesor/a',    # L√≠nea 60: Rol de Profesor.
    'ESTUDIANTE': 'Estudiante'   # L√≠nea 61: Rol de Estudiante.
}                                # L√≠nea 62: Fin del diccionario de roles.

# Usuarios de prueba (Mock) y sus roles
USUARIOS_MOCK = {                # L√≠nea 65: Inicio del diccionario de usuarios de prueba.
    '0': ROLES['DIRECTOR'],      # L√≠nea 66: ID 0 es el Director.
    '1001': ROLES['PROFESOR'],   # L√≠nea 67: ID 1001 es el Profesor de Matem√°ticas.
    '1002': ROLES['PROFESOR'],   # L√≠nea 68: ID 1002 es el Profesor de Lengua.
    '2001': ROLES['ESTUDIANTE'], # L√≠nea 69: ID 2001 es el Estudiante A.
    '2002': ROLES['ESTUDIANTE'], # L√≠nea 70: ID 2002 es el Estudiante B.
    '2003': ROLES['ESTUDIANTE']  # L√≠nea 71: ID 2003 es el Estudiante C.
}                                # L√≠nea 72: Fin del diccionario de usuarios.

# Asignaturas de prueba
ASIGNATURAS_MOCK = {             # L√≠nea 75: Inicio del diccionario de asignaturas.
    'MAT': 'Matem√°ticas',        # L√≠nea 76: Clave 'MAT' para Matem√°ticas.
    'LEN': 'Lengua Espa√±ola',    # L√≠nea 77: Clave 'LEN' para Lengua Espa√±ola.
    'SOC': 'Ciencias Sociales'   # L√≠nea 78: Clave 'SOC' para Ciencias Sociales.
}                                # L√≠nea 79: Fin del diccionario de asignaturas.

# Asignaci√≥n de asignaturas a profesores (para la l√≥gica de llenado de notas)
ASIGNACION_PROFESOR = {          # L√≠nea 82: Inicio del diccionario de asignaci√≥n.
    '1001': ['MAT', 'SOC'],      # L√≠nea 83: Profesor 1001 da Matem√°ticas y Sociales.
    '1002': ['LEN']              # L√≠nea 84: Profesor 1002 da Lengua.
}                                # L√≠nea 85: Fin del diccionario de asignaci√≥n.

# --- 3. Clase GeneradorIDs (Manejo de IDs √önicos) --- (L√≠neas 88-142)

def get_max_mock_id(users_mock): # L√≠nea 88: Funci√≥n para encontrar la ID m√°s alta entre los usuarios de prueba.
    """Obtiene el ID num√©rico m√°ximo de los usuarios de prueba.""" # L√≠nea 89: Docstring (explicaci√≥n de la funci√≥n).
    try:                         # L√≠nea 90: Intenta el siguiente c√≥digo.
        # Convierte todas las claves de ID a n√∫meros enteros y encuentra el m√°ximo.
        return max([int(k) for k in users_mock.keys()]) # L√≠nea 92: Devuelve el valor m√°s grande de la lista de IDs convertidas.
    except ValueError:           # L√≠nea 93: Si algo falla (ej. una ID no es un n√∫mero)...
        return 0                 # L√≠nea 94: Devuelve 0 como valor seguro.

class GeneradorIDs:              # L√≠nea 96: Define la clase (el molde) para gestionar los n√∫meros de ID.
    """Clase para gestionar la generaci√≥n de IDs secuenciales y de hash.""" # L√≠nea 97: Docstring de la clase.

    def __init__(self, counter_file=ID_COUNTER_FILE): # L√≠nea 99: Constructor. Se ejecuta al crear un objeto GeneradorIDs.
        self.counter_file = counter_file             # L√≠nea 100: Guarda el nombre del archivo del contador.
        self.max_mock_id = get_max_mock_id(USUARIOS_MOCK) # L√≠nea 101: Guarda la ID m√°s alta de los usuarios de prueba.
        self.current_id = 0                          # L√≠nea 102: Inicializa el contador de ID actual a cero.
        self._initialize_counter()                   # L√≠nea 103: Llama al m√©todo interno para cargar el contador desde el disco.

    def _initialize_counter(self): # L√≠nea 105: M√©todo interno para leer el √∫ltimo ID guardado.
        """Establece el contador inicial leyendo el archivo o usando el max mock id.""" # L√≠nea 106: Docstring.
        if os.path.exists(self.counter_file):        # L√≠nea 107: Pregunta: ¬øExiste el archivo del contador?
            try:                                     # L√≠nea 108: Si existe, intenta leerlo.
                with open(self.counter_file, 'r') as f: # L√≠nea 109: Abre el archivo en modo lectura ('r').
                    content = f.read().strip()       # L√≠nea 110: Lee el contenido y elimina espacios extra.
                    if content:                      # L√≠nea 111: Si el archivo no est√° vac√≠o...
                        # Asegura que el contador no sea menor que la ID m√°s alta de prueba.
                        self.current_id = max(self.max_mock_id, int(content)) # L√≠nea 113: Toma el mayor entre la ID del archivo y la ID de prueba.
                    else:                            # L√≠nea 114: Si el archivo est√° vac√≠o...
                        self.current_id = self.max_mock_id # L√≠nea 115: Usa la ID m√°s alta de prueba.
            except Exception as e:                   # L√≠nea 116: Si hay un error al leer el archivo...
                print(f"Error al leer contador de ID: {e}") # L√≠nea 117: Imprime el error.
                self.current_id = self.max_mock_id   # L√≠nea 118: Usa el valor seguro.
        else:                                        # L√≠nea 119: Si el archivo del contador no existe...
            self.current_id = self.max_mock_id       # L√≠nea 120: Usa la ID m√°s alta de prueba.

    def generar_id_secuencial(self): # L√≠nea 122: M√©todo para crear un nuevo ID num√©rico.
        """Incrementa y guarda el contador, luego devuelve la nueva ID.""" # L√≠nea 123: Docstring.
        self.current_id += 1                         # L√≠nea 124: Suma 1 al contador actual.
        nuevo_id = str(self.current_id)              # L√≠nea 125: Convierte el nuevo n√∫mero a texto.
        try:                                         # L√≠nea 126: Intenta guardar el nuevo contador.
            with open(self.counter_file, 'w') as f:  # L√≠nea 127: Abre el archivo en modo escritura ('w') para sobrescribir.
                f.write(nuevo_id)                    # L√≠nea 128: Escribe el nuevo ID.
        except Exception as e:                       # L√≠nea 129: Si hay un error al guardar...
            print(f"Error al guardar contador de ID: {e}") # L√≠nea 130: Imprime el error.
        return nuevo_id                              # L√≠nea 131: Devuelve la nueva ID generada.

    @staticmethod                     # L√≠nea 133: Decorador que indica que esta funci√≥n no usa variables del objeto.
    def generar_id_registro(data_tuple): # L√≠nea 134: M√©todo est√°tico para crear la ID de registro √∫nica (el hash).
        """Genera un hash SHA-256 corto a partir de una tupla de datos clave.""" # L√≠nea 135: Docstring.
        # Los datos clave son: profesor_ID, estudiante_ID, periodo, asignatura.
        data_str = "".join(map(str, data_tuple)) # L√≠nea 137: Une todos los elementos de la tupla en una sola cadena de texto.
        # 1. Codifica la cadena a bytes (.encode()).
        # 2. Calcula el hash SHA-256.
        # 3. Lo convierte a texto hexadecimal (.hexdigest()).
        # 4. Lo trunca a los primeros 8 caracteres ([:8]) para que sea corto.
        return hashlib.sha256(data_str.encode()).hexdigest()[:8] # L√≠nea 142: Devuelve la ID de registro √∫nica.

id_manager = GeneradorIDs()              # L√≠nea 144: CREACI√ìN DEL OBJETO: Creamos la herramienta que gestionar√° las IDs.

# --- 4. Funciones de Gesti√≥n de Datos (Archivo CSV) --- (L√≠neas 147-194)

def inicializar_csv():                   # L√≠nea 147: Funci√≥n para asegurar que el archivo de datos existe.
    """Crea el archivo CSV con los encabezados si no existe.""" # L√≠nea 148: Docstring.
    if not os.path.exists(ARCHIVO_CSV):  # L√≠nea 149: Si el archivo principal NO existe...
        print("Inicializando archivo CSV...") # L√≠nea 150: Imprime un mensaje informativo.
        try:                             # L√≠nea 151: Intenta crear el archivo.
            # Crea un DataFrame (tabla) vac√≠o, solo con las columnas definidas.
            df_vacio = pd.DataFrame(columns=COLUMNS) # L√≠nea 153: Crea la tabla vac√≠a con los nombres de las columnas.
            # Guarda la tabla en el archivo CSV. index=False evita guardar los n√∫meros de fila de Pandas.
            df_vacio.to_csv(ARCHIVO_CSV, index=False, encoding='utf-8') # L√≠nea 155: Escribe la cabecera en el archivo.
            print("Archivo CSV creado exitosamente.") # L√≠nea 156: Confirma el √©xito.
        except Exception as e:           # L√≠nea 157: Si hay alg√∫n error al crear...
            print(f"Error al inicializar el archivo CSV: {e}") # L√≠nea 158: Imprime el error.

def cargar_datos():                      # L√≠nea 160: Funci√≥n para leer el archivo CSV y cargarlo en Pandas.
    """Carga los datos del CSV en un DataFrame de Pandas.""" # L√≠nea 161: Docstring.
    try:                                 # L√≠nea 162: Intenta leer el archivo.
        df = pd.read_csv(ARCHIVO_CSV, encoding='utf-8') # L√≠nea 163: Lee el CSV y lo guarda en 'df'.
        
        # --- Limpieza y tipado de datos para asegurar consistencia ---
        # Convertir IDs a texto (string) para evitar problemas de formato.
        df['profesor_ID'] = df['profesor_ID'].astype(str) # L√≠nea 167: Asegura que la columna 'profesor_ID' sea texto.
        df['estudiante_ID'] = df['estudiante_ID'].astype(str) # L√≠nea 168: Asegura que la columna 'estudiante_ID' sea texto.
        
        # Rellenar cualquier valor faltante (NaN) con el valor por defecto "N/A"
        for col in CALIFICACION_CAMPOS + ['P_NOTA_FINAL', 'P_LETRA_FINAL']: # L√≠nea 171: Bucle que recorre las columnas de notas y finales.
            df[col] = df[col].fillna(ESTADO_INICIAL_NOTA) # L√≠nea 172: Rellena los huecos (NaN) con "N/A".
            
        # Asegurar que las columnas de True/False son booleanas
        df['estado_publicacion'] = df['estado_publicacion'].fillna(False).astype(bool) # L√≠nea 175: Trata los faltantes como False, y convierte la columna a Booleano.
        df['estado_revision'] = df['estado_revision'].fillna(False).astype(bool)       # L√≠nea 176: Similar para el estado de revisi√≥n.
        
        return df                        # L√≠nea 178: Devuelve la tabla de datos cargada y lista para usar.
    
    except FileNotFoundError:            # L√≠nea 180: Si el archivo no se encuentra...
        print(f"Archivo {ARCHIVO_CSV} no encontrado. Creando DataFrame vac√≠o.") # L√≠nea 181: Imprime que el archivo no est√°.
        # Devuelve una tabla vac√≠a para que el programa pueda seguir sin romperse.
        return pd.DataFrame(columns=COLUMNS) # L√≠nea 183: Devuelve la tabla vac√≠a.
    
    except Exception as e:               # L√≠nea 185: Si hay cualquier otro error (inesperado)...
        print(f"Error desconocido al cargar datos: {e}") # L√≠nea 186: Imprime el error.
        return pd.DataFrame(columns=COLUMNS) # L√≠nea 187: Devuelve la tabla vac√≠a.

def guardar_datos(df):                   # L√≠nea 189: Funci√≥n para guardar el DataFrame actualizado al CSV.
    """Guarda el DataFrame actual en el archivo CSV.""" # L√≠nea 190: Docstring.
    try:                                 # L√≠nea 191: Intenta guardar el archivo.
        # Escribe la tabla de datos en el CSV, sobrescribiendo el contenido anterior.
        df.to_csv(ARCHIVO_CSV, index=False, encoding='utf-8') # L√≠nea 193: Guarda el DataFrame.
        print("Datos guardados exitosamente.") # L√≠nea 194: Confirma el √©xito.
    except Exception as e:                   # L√≠nea 195: Si hay un error al escribir...
        print(f"Error al guardar datos: {e}") # L√≠nea 196: Imprime el error.

# --- 5. L√≥gica de Negocio y C√°lculos --- (L√≠neas 199-247)

def verificar_permiso(user_id, accion): # L√≠nea 199: Funci√≥n de seguridad para ver si un usuario puede hacer algo.
    """Verifica si el ID de usuario tiene permiso para realizar una acci√≥n.""" # L√≠nea 200: Docstring.
    rol = USUARIOS_MOCK.get(user_id)     # L√≠nea 201: Busca el rol del usuario en la lista de prueba.
    
    # Esta es una versi√≥n simplificada: el Director/Profesor SIEMPRE tienen permisos en este mock.
    if rol in [ROLES['DIRECTOR'], ROLES['PROFESOR']]: # L√≠nea 204: Si el rol es Director o Profesor...
        # Los roles de gesti√≥n SIEMPRE tienen los permisos clave (llenar, publicar, ver)
        return accion in ['llenar_notas', 'publicar_notas', 'ver_registro', 'ver_reportes'] # L√≠nea 206: Devuelve True si la acci√≥n es una de gesti√≥n.
    
    elif rol == ROLES['ESTUDIANTE']:     # L√≠nea 208: Si el rol es Estudiante...
        # Los estudiantes solo pueden ver y solicitar revisi√≥n.
        return accion in ['ver_registro', 'solicitar_revision'] # L√≠nea 210: Devuelve True si la acci√≥n es ver o solicitar.
        
    return False                         # L√≠nea 212: Si la ID no se encuentra, devuelve False.

def calcular_nota_final(detalles):       # L√≠nea 214: Funci√≥n para calcular la nota final ponderada.
    """Calcula la nota final bas√°ndose en los pesos definidos.""" # L√≠nea 215: Docstring.
    nota_final = 0                       # L√≠nea 216: Inicializa la suma de la nota en 0.
    
    # Bucle que recorre cada campo (Participaci√≥n, Proyecto, etc.) y su peso.
    for campo, peso in PESOS_CALIFICACION.items(): # L√≠nea 219: Recorre el diccionario de pesos.
        # Obtiene la nota para ese campo. Si no existe en 'detalles', usa 0.
        valor = detalles.get(campo, 0)   # L√≠nea 221: Obtiene el valor de la nota parcial.
        nota_final += valor * peso       # L√≠nea 222: Suma a la nota final: (valor de la nota * su peso).
        
    return round(nota_final, 2)          # L√≠nea 224: Devuelve el resultado redondeado a 2 decimales.

def convertir_a_letra(nota):            # L√≠nea 226: Funci√≥n para convertir el n√∫mero a la letra de calificaci√≥n.
    """Convierte la nota num√©rica final a su representaci√≥n en letra.""" # L√≠nea 227: Docstring.
    if nota == ESTADO_INICIAL_NOTA:      # L√≠nea 228: Si la nota es "N/A"...
        return ESTADO_INICIAL_NOTA       # L√≠nea 229: Devuelve "N/A".
    
    try:                                 # L√≠nea 231: Intenta la conversi√≥n.
        nota = float(nota)               # L√≠nea 232: Convierte la nota a un n√∫mero decimal.
    except ValueError:                   # L√≠nea 233: Si no se puede convertir (ej. el texto es "Error")...
        return "Error"                   # L√≠nea 234: Devuelve "Error".
    
    # Es crucial iterar de mayor a menor para asignar la letra correcta.
    # Ejemplo: Si la nota es 91, debe ser 'A' (>= 90), no 'B' (>= 80).
    for limite, letra in sorted(ESCALA_CALIFICACION.items(), reverse=True): # L√≠nea 238: Bucle: Recorre la escala ordenada de mayor a menor.
        if nota >= limite:               # L√≠nea 239: Si la nota es mayor o igual al l√≠mite...
            return letra                 # L√≠nea 240: Devuelve la letra y detiene la funci√≥n.
            
    return 'F'                           # L√≠nea 242: Si no cumple con ning√∫n l√≠mite (ej. nota < 0), devuelve 'F'.

def es_registro_valido(registro):        # L√≠nea 244: Funci√≥n para comprobar si una nota tiene los campos necesarios.
    """Verifica que un registro (una fila de nota) contenga los campos clave.""" # L√≠nea 245: Docstring.
    campos_clave = ['profesor_ID', 'estudiante_ID', 'periodo', 'asignatura'] # L√≠nea 246: Los campos que son obligatorios.
    # Comprueba si TODOS los campos clave existen en el diccionario 'registro'.
    return all(campo in registro for campo in campos_clave) # L√≠nea 248: Devuelve True si todos los campos est√°n, False si falta alguno.

# --- 6. Funci√≥n de Alertas y Notificaciones --- (L√≠neas 250-305)

def check_alerts(df, user_id):           # L√≠nea 250: Funci√≥n que muestra mensajes importantes al iniciar sesi√≥n.
    """Muestra alertas espec√≠ficas al rol del usuario.""" # L√≠nea 251: Docstring.
    print("\n" + "="*40)                 # L√≠nea 252: Imprime una l√≠nea de separaci√≥n.
    print("--- üîî CENTRO DE NOTIFICACIONES Y ALERTA üîî ---") # L√≠nea 253: Imprime el t√≠tulo del centro de alertas.
    print("="*40)                        # L√≠nea 254: Imprime una l√≠nea de separaci√≥n.
    
    rol = USUARIOS_MOCK.get(user_id)     # L√≠nea 256: Obtiene el rol del usuario actual.
    
    if rol is None:                      # L√≠nea 258: Si el rol es nulo (no deber√≠a pasar aqu√≠, pero es una seguridad)...
        print("Error: Rol no identificado.") # L√≠nea 259: Imprime un error.
        return                           # L√≠nea 260: Termina la funci√≥n.
        
    # --- Alertas para Profesores/Directores ---
    if rol in [ROLES['PROFESOR'], ROLES['DIRECTOR']]: # L√≠nea 264: Si es Director o Profesor...
        
        # 1. Alerta de Solicitudes de Revisi√≥n Pendientes
        filtro_rev = (df['estado_revision'] == True) # L√≠nea 267: Filtro: todas las filas con estado_revision = True.
        
        if rol == ROLES['PROFESOR']:         # L√≠nea 269: Si es Profesor...
            # Limita el filtro solo a las notas que √©l ingres√≥.
            filtro_rev = filtro_rev & (df['profesor_ID'] == user_id) # L√≠nea 271: Agrega la condici√≥n: ID del profesor = ID del usuario.
            
        solicitudes_pendientes = df[filtro_rev] # L√≠nea 273: Aplica el filtro para obtener las filas.
        
        if not solicitudes_pendientes.empty: # L√≠nea 275: Si la tabla de resultados NO est√° vac√≠a...
            num_rev = len(solicitudes_pendientes) # L√≠nea 276: Cuenta cu√°ntas solicitudes hay.
            print(f"üö® TIENES {num_rev} SOLICITUDES DE REVISI√ìN PENDIENTES. ¬°Acciona el men√∫ de revisi√≥n!") # L√≠nea 277: Imprime la alerta.
        else:                                # L√≠nea 278: Si no hay solicitudes...
            print("‚úÖ No hay solicitudes de revisi√≥n pendientes.") # L√≠nea 279: Imprime el mensaje de √©xito.
            
        # 2. Alerta de Notas Ingresadas, No Publicadas (Riesgo de Plazo)
        filtro_pub = (df['estado_publicacion'] == False) & (df['P_NOTA_FINAL'] != ESTADO_INICIAL_NOTA) # L√≠nea 282: Filtro: notas NO publicadas, pero S√ç calculadas.
        if rol == ROLES['PROFESOR']:         # L√≠nea 284: Si es Profesor...
            filtro_pub = filtro_pub & (df['profesor_ID'] == user_id) # L√≠nea 285: Limita el filtro solo a sus notas.
            
        pendientes_pub = df[filtro_pub]      # L√≠nea 287: Aplica el filtro.
        
        if not pendientes_pub.empty:         # L√≠nea 289: Si hay notas pendientes de publicar...
            num_pub = len(pendientes_pub)    # L√≠nea 290: Cuenta cu√°ntas son.
            print(f"‚ö†Ô∏è TIENES {num_pub} NOTAS INGRESADAS PERO NO PUBLICADAS. ¬°Publica pronto!") # L√≠nea 291: Imprime la alerta de publicaci√≥n.
            
    # --- Alertas para Estudiantes ---
    elif rol == ROLES['ESTUDIANTE']:         # L√≠nea 295: Si el usuario es un Estudiante...
        # Alerta de Notas Publicadas
        filtro_est = (df['estudiante_ID'] == user_id) & (df['estado_publicacion'] == True) # L√≠nea 298: Filtro: notas del estudiante Y publicadas.
        notas_publicadas = df[filtro_est]    # L√≠nea 299: Aplica el filtro.
        
        if not notas_publicadas.empty:       # L√≠nea 301: Si hay notas publicadas...
            num_pub = len(notas_publicadas)  # L√≠nea 302: Cuenta cu√°ntas son.
            print(f"‚≠ê ¬°Tienes {num_pub} notas NUEVAS PUBLICADAS! Revisa tus calificaciones.") # L√≠nea 303: Imprime la alerta de nuevas notas.
        else:                                # L√≠nea 304: Si no hay notas...
            print("‚è≥ A√∫n no tienes notas publicadas para revisar.") # L√≠nea 305: Imprime mensaje de espera.
            
    print("="*40)                            # L√≠nea 307: Imprime una l√≠nea de cierre.
    time.sleep(1)                            # L√≠nea 308: Hace una pausa de 1 segundo para que el usuario pueda leer las alertas.

# --- 7. Funciones de Flujo (Men√∫s y Acciones) --- (L√≠neas 311-827)
# Debido a la restricci√≥n de 822 l√≠neas, esta secci√≥n es muy detallada.

def mostrar_registro_usuario(df, user_id, rol): # L√≠nea 311: Funci√≥n para mostrar las notas al usuario.
    """Muestra las notas relevantes para el usuario (Profesor/Estudiante).""" # L√≠nea 312: Docstring.
    if not verificar_permiso(user_id, 'ver_registro'): # L√≠nea 313: Verifica el permiso.
        print("Permiso denegado.")            # L√≠nea 314: Deniega si no hay permiso.
        return                               # L√≠nea 315: Termina.
    
    print("\n--- REGISTRO DE CALIFICACIONES ---") # L√≠nea 317: T√≠tulo.
    
    if rol == ROLES['ESTUDIANTE']:           # L√≠nea 319: Si es Estudiante...
        # Filtra solo las notas del estudiante, y solo las que est√°n publicadas.
        filtro = (df['estudiante_ID'] == user_id) & (df['estado_publicacion'] == True) # L√≠nea 321: El filtro.
        columnas_a_mostrar = ['periodo', 'asignatura', 'P_PARTICIPACION', 'P_PROYECTO', # L√≠nea 322: Columnas visibles para el estudiante.
                              'P_TAREA', 'P_EXAMEN', 'P_NOTA_FINAL', 'P_LETRA_FINAL', 'estado_revision'] # L√≠nea 323: M√°s columnas.
        
        df_mostrar = df[filtro][columnas_a_mostrar] # L√≠nea 325: Aplica el filtro y selecciona las columnas.
        print(f"Mostrando notas PUBLICADAS para el Estudiante ID {user_id}:") # L√≠nea 326: Mensaje.
        
    elif rol in [ROLES['PROFESOR'], ROLES['DIRECTOR']]: # L√≠nea 328: Si es Profesor o Director...
        # Filtra todas las notas si es Director, o solo las suyas si es Profesor.
        filtro = (df['profesor_ID'] == user_id) if rol == ROLES['PROFESOR'] else (df['estudiante_ID'].isin(USUARIOS_MOCK.keys())) # L√≠nea 330: Si es profesor, sus notas; si es director, todas las de los estudiantes mock.
        columnas_a_mostrar = COLUMNS # L√≠nea 331: Muestra TODAS las columnas.
        df_mostrar = df[filtro][columnas_a_mostrar] # L√≠nea 332: Aplica el filtro y muestra todas las columnas.
        print(f"Mostrando TODOS los registros bajo la ID {user_id} ({rol}):") # L√≠nea 333: Mensaje.

    if df_mostrar.empty:                     # L√≠nea 335: Si la tabla filtrada est√° vac√≠a...
        print("No hay registros para mostrar.") # L√≠nea 336: Mensaje de que no hay datos.
    else:                                    # L√≠nea 337: Si hay datos...
        # Muestra la tabla de datos sin el √≠ndice de Pandas (n√∫meros de fila).
        print(df_mostrar.to_string(index=False)) # L√≠nea 339: Imprime la tabla completa en texto.

    input("\nPresione Enter para continuar...") # L√≠nea 341: Pausa para que el usuario pueda revisar la tabla.

def obtener_input_numerico(prompt, min_val, max_val): # L√≠nea 343: Funci√≥n para pedir un n√∫mero v√°lido.
    """Solicita al usuario un n√∫mero entre min_val y max_val.""" # L√≠nea 344: Docstring.
    while True:                                  # L√≠nea 345: Bucle infinito hasta que se ingrese un valor correcto.
        try:                                     # L√≠nea 346: Intenta el c√≥digo.
            valor = input(prompt)                # L√≠nea 347: Pide el valor al usuario.
            if valor.strip().upper() == ESTADO_INICIAL_NOTA: # L√≠nea 348: Si el usuario escribe "N/A"...
                return ESTADO_INICIAL_NOTA       # L√≠nea 349: Devuelve la constante "N/A".
            
            numero = float(valor)                # L√≠nea 351: Convierte el input a n√∫mero decimal.
            if min_val <= numero <= max_val:     # L√≠nea 352: Comprueba si el n√∫mero est√° en el rango permitido.
                return numero                    # L√≠nea 353: Si est√° bien, devuelve el n√∫mero.
            else:                                # L√≠nea 354: Si est√° fuera del rango...
                print(f"Error: El valor debe estar entre {min_val} y {max_val}.") # L√≠nea 355: Mensaje de error de rango.
        except ValueError:                       # L√≠nea 356: Si el input no se puede convertir a n√∫mero...
            print("Error: Ingrese un n√∫mero v√°lido (ej. 85 o 92.5).") # L√≠nea 357: Mensaje de error de formato.

def llenar_nota_registro(df, user_id, estudiante_id, asignatura_clave, periodo='P1'): # L√≠nea 359: Funci√≥n para ingresar notas parciales.
    """Permite al profesor/director llenar las notas parciales de un registro.""" # L√≠nea 360: Docstring.
    print(f"\n--- Llenando Notas para Estudiante ID: {estudiante_id} / Asignatura: {ASIGNATURAS_MOCK[asignatura_clave]} ---") # L√≠nea 362: T√≠tulo.
    
    # 1. Crear la huella digital para buscar/crear el registro.
    registro_id = id_manager.generar_id_registro((user_id, estudiante_id, periodo, asignatura_clave)) # L√≠nea 365: Genera el ID √∫nico del registro.
    
    # 2. Buscar si el registro ya existe.
    filtro_existente = (df['ID_REGISTRO'] == registro_id) # L√≠nea 368: Filtro para buscar la fila con ese ID √∫nico.
    
    if df[filtro_existente].empty:           # L√≠nea 370: Si el DataFrame filtrado est√° vac√≠o (el registro es NUEVO)...
        print("Creando nuevo registro...")    # L√≠nea 371: Mensaje.
        # Crear un nuevo registro con valores por defecto.
        nuevo_registro = {                   # L√≠nea 373: Diccionario para la nueva fila.
            'ID_REGISTRO': registro_id,      # L√≠nea 374: El ID √∫nico.
            'profesor_ID': user_id,          # L√≠nea 375: La ID del profesor actual.
            'estudiante_ID': estudiante_id,  # L√≠nea 376: La ID del estudiante.
            'periodo': periodo,              # L√≠nea 377: El periodo.
            'asignatura': asignatura_clave,  # L√≠nea 378: La clave de la asignatura.
            'fecha_ingreso': str(date.today()), # L√≠nea 379: La fecha de hoy.
            'estado_publicacion': False,     # L√≠nea 380: Por defecto, no publicado.
            'estado_revision': False,        # L√≠nea 381: Por defecto, sin revisi√≥n pendiente.
            'P_DETALLES_JSON': json.dumps({}) # L√≠nea 382: JSON vac√≠o para los detalles.
        }                                    # L√≠nea 383: Fin del diccionario.
        # Rellenar los campos de notas con "N/A".
        for campo in CALIFICACION_CAMPOS:    # L√≠nea 385: Bucle para rellenar las notas.
            nuevo_registro[campo] = ESTADO_INICIAL_NOTA # L√≠nea 386: Asigna "N/A" a cada campo de nota.
        
        df_temp = pd.DataFrame([nuevo_registro]) # L√≠nea 388: Crea una tabla temporal con la nueva fila.
        df = pd.concat([df, df_temp], ignore_index=True) # L√≠nea 389: Agrega la nueva fila a la tabla principal.
        
        # Necesitamos volver a aplicar el filtro para obtener el √≠ndice de la nueva fila.
        filtro_existente = (df['ID_REGISTRO'] == registro_id) # L√≠nea 392: Re-aplica el filtro.

    # 3. Obtener el √≠ndice (n√∫mero de fila) del registro a modificar.
    index_to_update = df[filtro_existente].index[0] # L√≠nea 395: Obtiene el n√∫mero de fila (√≠ndice) donde est√° el registro.
    
    # 4. Cargar los detalles JSON (por si hay notas parciales guardadas)
    detalles_json = df.loc[index_to_update, 'P_DETALLES_JSON'] # L√≠nea 398: Lee el campo JSON de la fila.
    try:                                             # L√≠nea 399: Intenta decodificar el JSON.
        detalles_previos = json.loads(detalles_json) # L√≠nea 400: Convierte el texto JSON a un diccionario.
    except (json.JSONDecodeError, TypeError):        # L√≠nea 401: Si falla la decodificaci√≥n...
        detalles_previos = {}                        # L√≠nea 402: Usa un diccionario vac√≠o.

    # 5. Pedir y validar cada nota parcial.
    print("\nIngrese las notas (0-100). Escriba 'N/A' si a√∫n no aplica:") # L√≠nea 405: Instrucci√≥n.
    notas_ingresadas = {}                            # L√≠nea 406: Diccionario para guardar las notas que se van a ingresar.
    
    for campo in CALIFICACION_CAMPOS:                # L√≠nea 408: Bucle que recorre Participaci√≥n, Proyecto, Tarea, Examen.
        nota_previa = df.loc[index_to_update, campo] # L√≠nea 409: Lee el valor de la nota que ya est√° guardada.
        prompt = f"  {campo.replace('P_', '')} (Peso: {PESOS_CALIFICACION[campo]*100}% - Actual: {nota_previa}): " # L√≠nea 410: Crea el mensaje para el input.
        
        nueva_nota = obtener_input_numerico(prompt, 0, 100) # L√≠nea 412: Llama a la funci√≥n de validaci√≥n num√©rica.
        notas_ingresadas[campo] = nueva_nota         # L√≠nea 413: Guarda la nota en el diccionario.
        
        # 6. Actualizar el DataFrame con la nueva nota.
        df.loc[index_to_update, campo] = nueva_nota  # L√≠nea 416: Escribe la nueva nota en la fila y columna correcta.

    # 7. Recalcular la nota final.
    # Solo calcula si se han ingresado todos los campos (o son n√∫meros v√°lidos).
    notas_a_calcular = {k: v for k, v in notas_ingresadas.items() if isinstance(v, (int, float))} # L√≠nea 420: Crea un diccionario solo con las notas que son n√∫meros.
    
    if len(notas_a_calcular) == len(CALIFICACION_CAMPOS): # L√≠nea 422: Si se ingresaron n√∫meros en TODAS las categor√≠as...
        nota_final = calcular_nota_final(notas_a_calcular) # L√≠nea 423: Llama a la funci√≥n para calcular el promedio ponderado.
        letra_final = convertir_a_letra(nota_final)  # L√≠nea 424: Llama a la funci√≥n para convertir el n√∫mero a letra.
        
        # 8. Actualizar las columnas de Nota Final.
        df.loc[index_to_update, 'P_NOTA_FINAL'] = nota_final # L√≠nea 427: Guarda la nota num√©rica final.
        df.loc[index_to_update, 'P_LETRA_FINAL'] = letra_final # L√≠nea 428: Guarda la nota en letra final.
        print(f"\n‚úÖ NOTA FINAL CALCULADA: {nota_final} ({letra_final})") # L√≠nea 429: Mensaje de √©xito.
        
        # Si se calcul√≥, es una modificaci√≥n mayor, por lo que se marca como no publicado.
        df.loc[index_to_update, 'estado_publicacion'] = False # L√≠nea 432: Marca el registro como NO publicado (requiere republicaci√≥n).
    
    else:                                            # L√≠nea 434: Si falta alguna nota por ingresar...
        df.loc[index_to_update, 'P_NOTA_FINAL'] = ESTADO_INICIAL_NOTA # L√≠nea 435: Deja la nota final como "N/A".
        df.loc[index_to_update, 'P_LETRA_FINAL'] = ESTADO_INICIAL_NOTA # L√≠nea 436: Deja la letra final como "N/A".
        print("\n‚è≥ NOTA FINAL PENDIENTE: Faltan campos por completar.") # L√≠nea 437: Mensaje de nota pendiente.
        
    df.loc[index_to_update, 'fecha_ingreso'] = str(date.today()) # L√≠nea 439: Actualiza la fecha de la √∫ltima modificaci√≥n.
    guardar_datos(df)                                # L√≠nea 440: Llama a la funci√≥n para guardar todos los cambios al CSV.
    return df                                        # L√≠nea 441: Devuelve el DataFrame actualizado.

def menu_profesor_llenado_notas(df, user_id, periodo='P1'): # L√≠nea 443: Sub-men√∫ para que el profesor llene notas.
    """Men√∫ para que el profesor seleccione el estudiante y asignatura a calificar.""" # L√≠nea 444: Docstring.
    asignaturas_profesor = ASIGNACION_PROFESOR.get(user_id, []) # L√≠nea 445: Obtiene la lista de asignaturas del profesor.
    
    if not asignaturas_profesor:             # L√≠nea 447: Si la lista est√° vac√≠a...
        print("Usted no tiene asignaturas asignadas para calificar.") # L√≠nea 448: Mensaje.
        input("Presione Enter para continuar...") # L√≠nea 449: Pausa.
        return df                            # L√≠nea 450: Termina la funci√≥n.
        
    estudiantes_ids = [k for k, v in USUARIOS_MOCK.items() if v == ROLES['ESTUDIANTE']] # L√≠nea 452: Lista de IDs de estudiantes.
    
    while True:                              # L√≠nea 454: Bucle principal del sub-men√∫.
        print("\n--- INGRESO DE NOTAS ---") # L√≠nea 455: T√≠tulo.
        print(f"Profesor ID: {user_id}. Periodo: {periodo}.") # L√≠nea 456: Info.
        print("-" * 30)                      # L√≠nea 457: Separador.
        
        # Paso 1: Seleccionar Estudiante
        print("Estudiantes disponibles:")     # L√≠nea 460: Lista de estudiantes.
        for i, est_id in enumerate(estudiantes_ids): # L√≠nea 461: Bucle para mostrar la lista.
            print(f"  {i+1}. ID: {est_id}")  # L√≠nea 462: Muestra el √≠ndice (1, 2, 3...) y la ID del estudiante.
            
        est_idx_str = input("Seleccione el n√∫mero del estudiante (o '0' para volver): ").strip() # L√≠nea 464: Pide la selecci√≥n.
        if est_idx_str == '0':               # L√≠nea 465: Si escribe '0'...
            return df                        # L√≠nea 466: Vuelve al men√∫ anterior.
            
        try:                                 # L√≠nea 468: Intenta convertir a n√∫mero.
            est_idx = int(est_idx_str) - 1   # L√≠nea 469: Convierte a n√∫mero y resta 1 (para usar como √≠ndice de lista).
            estudiante_id = estudiantes_ids[est_idx] # L√≠nea 470: Obtiene la ID del estudiante seleccionado.
        except (ValueError, IndexError):     # L√≠nea 471: Si la conversi√≥n o el √≠ndice es incorrecto...
            print("Selecci√≥n no v√°lida. Intente de nuevo.") # L√≠nea 472: Mensaje de error.
            continue                         # L√≠nea 473: Vuelve al inicio del bucle.
            
        # Paso 2: Seleccionar Asignatura
        print("\nAsignaturas a calificar:")  # L√≠nea 476: T√≠tulo.
        for i, asig_clave in enumerate(asignaturas_profesor): # L√≠nea 477: Bucle para mostrar las asignaturas del profesor.
            print(f"  {i+1}. {ASIGNATURAS_MOCK[asig_clave]} ({asig_clave})") # L√≠nea 478: Muestra el nombre y la clave.
            
        asig_idx_str = input("Seleccione el n√∫mero de la asignatura (o '0' para volver): ").strip() # L√≠nea 480: Pide la selecci√≥n.
        if asig_idx_str == '0':              # L√≠nea 481: Si escribe '0'...
            continue                         # L√≠nea 482: Vuelve al paso 1 (selecci√≥n de estudiante).
            
        try:                                 # L√≠nea 484: Intenta convertir a n√∫mero.
            asig_idx = int(asig_idx_str) - 1 # L√≠nea 485: Convierte a n√∫mero y resta 1.
            asignatura_clave = asignaturas_profesor[asig_idx] # L√≠nea 486: Obtiene la clave de la asignatura.
        except (ValueError, IndexError):     # L√≠nea 487: Si la conversi√≥n o el √≠ndice es incorrecto...
            print("Selecci√≥n no v√°lida. Intente de nuevo.") # L√≠nea 488: Mensaje de error.
            continue                         # L√≠nea 489: Vuelve al inicio del bucle.
            
        # Paso 3: Llenar las notas para la selecci√≥n.
        df = llenar_nota_registro(df, user_id, estudiante_id, asignatura_clave, periodo) # L√≠nea 492: Llama a la funci√≥n que pide las notas.

def menu_profesor_publicacion(df, user_id, periodo='P1'): # L√≠nea 494: Sub-men√∫ para publicar notas.
    """Men√∫ para que el profesor publique las notas de sus asignaturas.""" # L√≠nea 495: Docstring.
    if not verificar_permiso(user_id, 'publicar_notas'): # L√≠nea 496: Verifica el permiso.
        print("Permiso denegado.")            # L√≠nea 497: Mensaje.
        return df                            # L√≠nea 498: Termina.

    print("\n--- PUBLICACI√ìN DE CALIFICACIONES ---") # L√≠nea 500: T√≠tulo.
    
    # Filtro para encontrar notas calculadas, no publicadas y que pertenecen a este profesor.
    filtro_pub = (df['profesor_ID'] == user_id) & \
                 (df['estado_publicacion'] == False) & \
                 (df['periodo'] == periodo) & \
                 (df['P_NOTA_FINAL'] != ESTADO_INICIAL_NOTA) # L√≠nea 505: Filtro de 4 condiciones.
                 
    pendientes_pub = df[filtro_pub]          # L√≠nea 507: Aplica el filtro.
    
    if pendientes_pub.empty:                 # L√≠nea 509: Si no hay notas para publicar...
        print(f"No hay notas completas y no publicadas en el Periodo {periodo}.") # L√≠nea 510: Mensaje.
        input("Presione Enter para continuar...") # L√≠nea 511: Pausa.
        return df                            # L√≠nea 512: Termina.
        
    print(f"Se encontraron {len(pendientes_pub)} registros listos para publicaci√≥n:") # L√≠nea 514: Mensaje con el conteo.
    # Mostrar solo la informaci√≥n clave.
    print(pendientes_pub[['estudiante_ID', 'asignatura', 'P_NOTA_FINAL']].to_string(index=False)) # L√≠nea 516: Muestra la lista de notas a publicar.

    confirm = input("¬øDesea PUBLICAR todas estas notas? (S/N): ").strip().upper() # L√≠nea 518: Pide confirmaci√≥n.
    
    if confirm == 'S':                       # L√≠nea 520: Si la respuesta es 'S'...
        # Establece el estado_publicacion a True para todas las filas que cumplen el filtro.
        df.loc[filtro_pub, 'estado_publicacion'] = True # L√≠nea 522: Actualiza la columna 'estado_publicacion' a True.
        guardar_datos(df)                    # L√≠nea 523: Guarda los cambios.
        print("\n‚úÖ Publicaci√≥n completada. Los estudiantes ya pueden ver estas notas.") # L√≠nea 524: Mensaje de √©xito.
    else:                                    # L√≠nea 525: Si la respuesta es 'N'...
        print("Publicaci√≥n cancelada.")      # L√≠nea 526: Mensaje.
        
    input("Presione Enter para continuar...") # L√≠nea 528: Pausa.
    return df                                # L√≠nea 529: Devuelve el DataFrame.

def menu_estudiante_revision(df, user_id, periodo='P1'): # L√≠nea 531: Sub-men√∫ para que el estudiante solicite revisi√≥n.
    """Permite al estudiante solicitar la revisi√≥n de una nota publicada.""" # L√≠nea 532: Docstring.
    if not verificar_permiso(user_id, 'solicitar_revision'): # L√≠nea 533: Verifica el permiso.
        print("Permiso denegado.")            # L√≠nea 534: Mensaje.
        return df                            # L√≠nea 535: Termina.
        
    print("\n--- SOLICITUD DE REVISI√ìN ---") # L√≠nea 537: T√≠tulo.
    
    # 1. Filtrar las notas publicadas del estudiante.
    filtro_est_pub = (df['estudiante_ID'] == user_id) & (df['estado_publicacion'] == True) # L√≠nea 540: Filtro: notas publicadas Y que pertenecen al estudiante.
    registros_disponibles = df[filtro_est_pub].copy() # L√≠nea 541: Copia de las notas disponibles (para mostrar).
    
    if registros_disponibles.empty:          # L√≠nea 543: Si no hay notas publicadas...
        print("No tiene notas publicadas para solicitar revisi√≥n.") # L√≠nea 544: Mensaje.
        input("Presione Enter para continuar...") # L√≠nea 545: Pausa.
        return df                            # L√≠nea 546: Termina.
        
    # 2. Mostrar las notas que se pueden revisar.
    registros_disponibles['indice'] = range(1, len(registros_disponibles) + 1) # L√≠nea 549: Agrega una columna temporal para enumerar las opciones (1, 2, 3...).
    
    print("\nNotas disponibles para revisi√≥n:") # L√≠nea 551: T√≠tulo.
    print(registros_disponibles[['indice', 'asignatura', 'P_LETRA_FINAL', 'fecha_ingreso', 'estado_revision']].to_string(index=False)) # L√≠nea 553: Muestra las notas clave.

    while True:                              # L√≠nea 555: Bucle para pedir la selecci√≥n.
        opcion_str = input("Seleccione el n√∫mero de la nota a revisar (o '0' para volver): ").strip() # L√≠nea 556: Pide la selecci√≥n.
        if opcion_str == '0':                # L√≠nea 557: Si elige '0'...
            return df                        # L√≠nea 558: Termina.
            
        try:                                 # L√≠nea 560: Intenta convertir a n√∫mero.
            opcion = int(opcion_str)         # L√≠nea 561: Convierte a n√∫mero.
            registro_selec = registros_disponibles[registros_disponibles['indice'] == opcion].iloc[0] # L√≠nea 562: Obtiene la fila seleccionada.
            index_to_update = registro_selec.name # L√≠nea 563: Obtiene el √≠ndice (n√∫mero de fila real) en el DataFrame principal.
        except (ValueError, IndexError):     # L√≠nea 564: Si la selecci√≥n es incorrecta...
            print("Selecci√≥n no v√°lida.")    # L√≠nea 565: Mensaje.
            continue                         # L√≠nea 566: Vuelve al inicio del bucle.
            
        # 3. Verificar el plazo de revisi√≥n (simulaci√≥n).
        fecha_ingreso = datetime.strptime(registro_selec['fecha_ingreso'], '%Y-%m-%d').date() # L√≠nea 569: Convierte la fecha de ingreso a un objeto de fecha.
        plazo_limite = fecha_ingreso + timedelta(days=PLAZO_REVISION_DIAS) # L√≠nea 570: Calcula la fecha l√≠mite (fecha de ingreso + 5 d√≠as).
        
        if date.today() > plazo_limite:      # L√≠nea 572: Si la fecha de hoy es posterior a la fecha l√≠mite...
            print(f"‚ùå Plazo vencido. El l√≠mite era hasta el {plazo_limite}.") # L√≠nea 573: Mensaje de error de plazo.
            continue                         # L√≠nea 574: Vuelve al inicio del bucle.

        # 4. Actualizar el estado de revisi√≥n.
        if registro_selec['estado_revision'] == True: # L√≠nea 577: Si ya est√° en revisi√≥n...
            print("Ya existe una solicitud de revisi√≥n pendiente para esta nota.") # L√≠nea 578: Mensaje.
            continue                         # L√≠nea 579: Vuelve al inicio del bucle.
            
        df.loc[index_to_update, 'estado_revision'] = True # L√≠nea 581: Marca el campo 'estado_revision' a True.
        guardar_datos(df)                    # L√≠nea 582: Guarda los cambios.
        
        profesor_id = registro_selec['profesor_ID'] # L√≠nea 584: Obtiene la ID del profesor.
        print(f"\n‚úÖ Solicitud de revisi√≥n enviada exitosamente al profesor ID {profesor_id}.") # L√≠nea 585: Mensaje de √©xito.
        
        input("Presione Enter para continuar...") # L√≠nea 587: Pausa.
        return df                            # L√≠nea 588: Termina la funci√≥n.

def menu_profesor_revision_pendiente(df, user_id, periodo='P1'): # L√≠nea 590: Sub-men√∫ para que el profesor revise solicitudes.
    """Permite al profesor gestionar las solicitudes de revisi√≥n pendientes.""" # L√≠nea 591: Docstring.
    if not verificar_permiso(user_id, 'ver_registro'): # L√≠nea 592: Verifica el permiso.
        print("Permiso denegado.")            # L√≠nea 593: Mensaje.
        return df                            # L√≠nea 594: Termina.
        
    print("\n--- GESTI√ìN DE REVISIONES PENDIENTES ---") # L√≠nea 596: T√≠tulo.
    
    # 1. Filtrar solicitudes de revisi√≥n para este profesor.
    filtro_rev = (df['profesor_ID'] == user_id) & (df['estado_revision'] == True) # L√≠nea 599: Filtro: notas del profesor Y con estado_revision = True.
    solicitudes = df[filtro_rev].copy()      # L√≠nea 600: Copia de las solicitudes.
    
    if solicitudes.empty:                    # L√≠nea 602: Si no hay solicitudes...
        print("No tiene solicitudes de revisi√≥n pendientes.") # L√≠nea 603: Mensaje.
        input("Presione Enter para continuar...") # L√≠nea 604: Pausa.
        return df                            # L√≠nea 605: Termina.
        
    # 2. Mostrar las solicitudes.
    solicitudes['indice'] = range(1, len(solicitudes) + 1) # L√≠nea 608: Agrega columna temporal para enumerar.
    
    print("\nSolicitudes pendientes:")       # L√≠nea 610: T√≠tulo.
    print(solicitudes[['indice', 'estudiante_ID', 'asignatura', 'P_NOTA_FINAL', 'P_LETRA_FINAL']].to_string(index=False)) # L√≠nea 612: Muestra las solicitudes.
    
    while True:                              # L√≠nea 614: Bucle para pedir la selecci√≥n.
        opcion_str = input("Seleccione el n√∫mero de la solicitud a gestionar (o '0' para volver): ").strip() # L√≠nea 615: Pide la selecci√≥n.
        if opcion_str == '0':                # L√≠nea 616: Si elige '0'...
            return df                        # L√≠nea 617: Termina.
            
        try:                                 # L√≠nea 619: Intenta convertir a n√∫mero.
            opcion = int(opcion_str)         # L√≠nea 620: Convierte a n√∫mero.
            solicitud_selec = solicitudes[solicitudes['indice'] == opcion].iloc[0] # L√≠nea 621: Obtiene la fila.
            index_to_update = solicitud_selec.name # L√≠nea 622: Obtiene el √≠ndice real.
        except (ValueError, IndexError):     # L√≠nea 623: Si la selecci√≥n es incorrecta...
            print("Selecci√≥n no v√°lida.")    # L√≠nea 624: Mensaje.
            continue                         # L√≠nea 625: Vuelve al inicio del bucle.
            
        print("\n--- GESTIONANDO SOLICITUD ---") # L√≠nea 627: T√≠tulo.
        print(f"Estudiante: {solicitud_selec['estudiante_ID']}, Asignatura: {ASIGNATURAS_MOCK[solicitud_selec['asignatura']]}") # L√≠nea 628: Info.
        
        # Opciones de gesti√≥n
        print("\nOpciones:")                  # L√≠nea 631: Opciones.
        print("1. Revisar (ir al men√∫ de llenado de notas para modificar la nota)") # L√≠nea 632: Opci√≥n 1.
        print("2. Marcar como Revisada (Aceptar nota y borrar solicitud)") # L√≠nea 633: Opci√≥n 2.
        
        gestion_opc = input("Seleccione una opci√≥n: ").strip() # L√≠nea 635: Pide la opci√≥n.

        if gestion_opc == '1':               # L√≠nea 637: Si elige '1' (Revisar)...
            # Redirigir al men√∫ de llenado, lo que le permite al profesor cambiar las notas.
            df = llenar_nota_registro(df, user_id, solicitud_selec['estudiante_ID'], solicitud_selec['asignatura'], periodo) # L√≠nea 640: Llama a la funci√≥n de llenado de notas.
            # Al modificar, se asume que la revisi√≥n fue atendida.
            df.loc[index_to_update, 'estado_revision'] = False # L√≠nea 642: Desactiva el estado de revisi√≥n.
            guardar_datos(df)                # L√≠nea 643: Guarda.
            print("\n‚úÖ Nota revisada y solicitud cerrada.") # L√≠nea 644: Mensaje.
            
        elif gestion_opc == '2':             # L√≠nea 646: Si elige '2' (Marcar como Revisada)...
            df.loc[index_to_update, 'estado_revision'] = False # L√≠nea 647: Desactiva el estado de revisi√≥n.
            guardar_datos(df)                # L√≠nea 648: Guarda.
            print("\n‚úÖ Solicitud de revisi√≥n cerrada sin modificaciones.") # L√≠nea 649: Mensaje.
            
        else:                                # L√≠nea 651: Si elige otra opci√≥n...
            print("Opci√≥n no v√°lida.")       # L√≠nea 652: Mensaje.

        # Actualizar la lista de solicitudes y volver al inicio del bucle.
        filtro_rev = (df['profesor_ID'] == user_id) & (df['estado_revision'] == True) # L√≠nea 656: Re-aplica el filtro.
        solicitudes = df[filtro_rev].copy()      # L√≠nea 657: Actualiza la lista.
        if solicitudes.empty: break # L√≠nea 658: Si ya no hay solicitudes, sale del bucle.
        
        input("Presione Enter para continuar...") # L√≠nea 660: Pausa.

def flujo_director(df, user_id, periodo='P1'): # L√≠nea 662: Funci√≥n de flujo para el Director.
    """Men√∫ principal para el rol de Director/a.""" # L√≠nea 663: Docstring.
    while True:                                  # L√≠nea 664: Bucle principal del men√∫.
        print("\n" + "#"*40)                     # L√≠nea 665: Separador.
        print("--- MEN√ö DIRECTOR --- (ID: 0)") # L√≠nea 666: T√≠tulo.
        check_alerts(df, user_id)                # L√≠nea 667: Llama a las alertas.
        print("1. Llenar/Modificar Notas (Acceso total)") # L√≠nea 668: Opci√≥n 1.
        print("2. Publicar Notas (Acceso total)") # L√≠nea 669: Opci√≥n 2.
        print("3. Ver Registro de Calificaciones (Acceso total)") # L√≠nea 670: Opci√≥n 3.
        print("4. Cerrar Sesi√≥n")                # L√≠nea 671: Opci√≥n 4.
        
        opc = input("Seleccione una opci√≥n: ").strip() # L√≠nea 673: Pide la opci√≥n.
        
        if opc == '1':                           # L√≠nea 675: Si elige 1...
            # El director usa el mismo men√∫ que el profesor para llenar, pero tiene acceso a todas las asignaturas/profesores (simulaci√≥n simplificada).
            df = menu_profesor_llenado_notas(df, user_id, periodo) # L√≠nea 678: Llama a la funci√≥n de llenado.
        elif opc == '2':                         # L√≠nea 679: Si elige 2...
            # El director publica todas las notas del periodo, independientemente del profesor.
            # Simulaci√≥n: Publicar todas las notas no publicadas con nota final.
            filtro_all_pub = (df['estado_publicacion'] == False) & \
                             (df['periodo'] == periodo) & \
                             (df['P_NOTA_FINAL'] != ESTADO_INICIAL_NOTA) # L√≠nea 684: Filtro para todas las notas listas.
            
            if df[filtro_all_pub].empty:         # L√≠nea 686: Si no hay notas...
                print("No hay notas completas y no publicadas en el Periodo para el Director.") # L√≠nea 687: Mensaje.
            else:                                # L√≠nea 688: Si hay notas...
                confirm = input(f"Se publicar√°n {len(df[filtro_all_pub])} registros. ¬øConfirmar? (S/N): ").strip().upper() # L√≠nea 690: Pide confirmaci√≥n.
                if confirm == 'S':               # L√≠nea 691: Si confirma...
                    df.loc[filtro_all_pub, 'estado_publicacion'] = True # L√≠nea 692: Publica.
                    guardar_datos(df)            # L√≠nea 693: Guarda.
                    print("‚úÖ Publicaci√≥n general completada.") # L√≠nea 694: Mensaje.
                else:                            # L√≠nea 695: Si cancela...
                    print("Publicaci√≥n cancelada.") # L√≠nea 696: Mensaje.
                    
        elif opc == '3':                         # L√≠nea 698: Si elige 3...
            mostrar_registro_usuario(df, user_id, ROLES['DIRECTOR']) # L√≠nea 699: Muestra el registro completo.
        elif opc == '4':                         # L√≠nea 700: Si elige 4...
            break                                # L√≠nea 701: Sale del bucle (Cerrar Sesi√≥n).
        else:                                    # L√≠nea 702: Si elige otra opci√≥n...
            print("Opci√≥n no v√°lida. Intente de nuevo.") # L√≠nea 703: Mensaje.
            
    return df                                    # L√≠nea 705: Devuelve el DataFrame.

def flujo_profesor(df, user_id, periodo='P1'): # L√≠nea 707: Funci√≥n de flujo para el Profesor.
    """Men√∫ principal para el rol de Profesor/a.""" # L√≠nea 708: Docstring.
    while True:                                  # L√≠nea 709: Bucle principal del men√∫.
        print("\n" + "#"*40)                     # L√≠nea 710: Separador.
        print(f"--- MEN√ö PROFESOR --- (ID: {user_id})") # L√≠nea 711: T√≠tulo.
        check_alerts(df, user_id)                # L√≠nea 712: Llama a las alertas.
        print("1. Llenar/Modificar Notas")       # L√≠nea 713: Opci√≥n 1.
        print("2. Publicar Notas")               # L√≠nea 714: Opci√≥n 2.
        print("3. Gestionar Solicitudes de Revisi√≥n") # L√≠nea 715: Opci√≥n 3.
        print("4. Ver Mis Registros")            # L√≠nea 716: Opci√≥n 4.
        print("5. Cerrar Sesi√≥n")                # L√≠nea 717: Opci√≥n 5.
        
        opc = input("Seleccione una opci√≥n: ").strip() # L√≠nea 719: Pide la opci√≥n.
        
        if opc == '1':                           # L√≠nea 721: Si elige 1...
            df = menu_profesor_llenado_notas(df, user_id, periodo) # L√≠nea 722: Llama a la funci√≥n de llenado.
        elif opc == '2':                         # L√≠nea 723: Si elige 2...
            df = menu_profesor_publicacion(df, user_id, periodo) # L√≠nea 724: Llama a la funci√≥n de publicaci√≥n.
        elif opc == '3':                         # L√≠nea 725: Si elige 3...
            df = menu_profesor_revision_pendiente(df, user_id, periodo) # L√≠nea 726: Llama a la funci√≥n de revisi√≥n.
        elif opc == '4':                         # L√≠nea 727: Si elige 4...
            mostrar_registro_usuario(df, user_id, ROLES['PROFESOR']) # L√≠nea 728: Muestra sus registros.
        elif opc == '5':                         # L√≠nea 729: Si elige 5...
            break                                # L√≠nea 730: Sale del bucle.
        else:                                    # L√≠nea 731: Si elige otra opci√≥n...
            print("Opci√≥n no v√°lida. Intente de nuevo.") # L√≠nea 732: Mensaje.
            
    return df                                    # L√≠nea 734: Devuelve el DataFrame.

def flujo_estudiante(df, user_id, periodo='P1'): # L√≠nea 736: Funci√≥n de flujo para el Estudiante.
    """Men√∫ principal para el rol de Estudiante.""" # L√≠nea 737: Docstring.
    while True:                                  # L√≠nea 738: Bucle principal del men√∫.
        print("\n" + "#"*40)                     # L√≠nea 739: Separador.
        print(f"--- MEN√ö ESTUDIANTE --- (ID: {user_id})") # L√≠nea 740: T√≠tulo.
        check_alerts(df, user_id)                # L√≠nea 741: Llama a las alertas.
        print("1. Ver Mis Calificaciones Publicadas") # L√≠nea 742: Opci√≥n 1.
        print("2. Solicitar Revisi√≥n de Nota")   # L√≠nea 743: Opci√≥n 2.
        print("3. Cerrar Sesi√≥n")                # L√≠nea 744: Opci√≥n 3.
        
        opc = input("Seleccione una opci√≥n: ").strip() # L√≠nea 746: Pide la opci√≥n.
        
        if opc == '1':                           # L√≠nea 748: Si elige 1...
            mostrar_registro_usuario(df, user_id, ROLES['ESTUDIANTE']) # L√≠nea 749: Muestra sus notas.
        elif opc == '2':                         # L√≠nea 750: Si elige 2...
            df = menu_estudiante_revision(df, user_id, periodo) # L√≠nea 751: Llama a la funci√≥n de solicitud de revisi√≥n.
        elif opc == '3':                         # L√≠nea 752: Si elige 3...
            break                                # L√≠nea 753: Sale del bucle.
        else:                                    # L√≠nea 754: Si elige otra opci√≥n...
            print("Opci√≥n no v√°lida. Intente de nuevo.") # L√≠nea 755: Mensaje.
            
    return df                                    # L√≠nea 757: Devuelve el DataFrame.

def menu_login():                                # L√≠nea 759: Funci√≥n de inicio de sesi√≥n.
    """Maneja el inicio de sesi√≥n y la selecci√≥n de rol.""" # L√≠nea 760: Docstring.
    while True:                                  # L√≠nea 761: Bucle de inicio de sesi√≥n.
        print("\n" + "="*50)                     # L√≠nea 762: Separador.
        print("--- SISTEMA DE REGISTRO DE CALIFICACIONES MINERD ---") # L√≠nea 763: T√≠tulo.
        print("="*50)                            # L√≠nea 764: Separador.
        print("IDs de prueba: 0 (Director), 1001/1002 (Profesor), 2001-2003 (Estudiante)") # L√≠nea 765: IDs de prueba.
        user_id = input("Ingrese su ID de usuario (o 'SALIR'): ").strip() # L√≠nea 766: Pide la ID.
        
        if user_id.upper() == 'SALIR':           # L√≠nea 768: Si escribe 'SALIR'...
            print("\nGuardando datos finales y saliendo...") # L√≠nea 769: Mensaje de cierre.
            time.sleep(1.5)                      # L√≠nea 770: Pausa.
            return None, None                    # L√≠nea 771: Devuelve None para cerrar.
            
        rol = USUARIOS_MOCK.get(user_id)         # L√≠nea 773: Busca el rol.
        
        if rol:                                  # L√≠nea 775: Si encontr√≥ un rol (ID v√°lida)...
            print(f"\n‚úÖ Sesi√≥n iniciada como {rol} (ID: {user_id}).") # L√≠nea 776: Mensaje de √©xito.
            return user_id, rol                  # L√≠nea 777: Devuelve la ID y el rol.
        else:                                    # L√≠nea 778: Si no encontr√≥ rol...
            print("ID de usuario no v√°lida. Intente de nuevo.") # L√≠nea 779: Mensaje de error.

# Variable global para contener el DataFrame (la tabla de datos) en todo el programa.
flujo_global_df = pd.DataFrame(columns=COLUMNS) # L√≠nea 782: Crea la tabla global (se llenar√° en main).

def main():                                      # L√≠nea 784: Funci√≥n principal de orquestaci√≥n.
    """Funci√≥n principal que inicia la aplicaci√≥n y gestiona el flujo.""" # L√≠nea 785: Docstring.
    global flujo_global_df                       # L√≠nea 786: Declara que usar√° la variable global de la l√≠nea 782.
    
    # --- 1. Inicializaci√≥n ---
    inicializar_csv()                            # L√≠nea 789: Asegura que el archivo CSV y la ID existen.
    flujo_global_df = cargar_datos()             # L√≠nea 790: Carga los datos del CSV a la tabla global.
    
    print("\nSistema iniciado. Total de registros cargados:", len(flujo_global_df)) # L√≠nea 792: Mensaje de inicio.
    
    # --- 2. Bucle de la Aplicaci√≥n (M√∫ltiples Sesiones) ---
    while True:                                  # L√≠nea 795: Bucle que mantiene el programa vivo (mientras el usuario no diga 'SALIR').
        try:                                     # L√≠nea 796: Intenta el siguiente bloque de c√≥digo.
            user_id, rol = menu_login()          # L√≠nea 797: Llama al inicio de sesi√≥n.
            
            if user_id is None:                  # L√≠nea 799: Si el inicio de sesi√≥n devolvi√≥ None (el usuario eligi√≥ SALIR)...
                break                            # L√≠nea 800: Rompe el bucle y termina el programa.
                
            # --- 3. Redirecci√≥n de Flujo ---
            if rol == ROLES['DIRECTOR']:         # L√≠nea 803: Si es Director...
                flujo_global_df = flujo_director(flujo_global_df, user_id) # L√≠nea 804: Llama al men√∫ del Director.
            elif rol == ROLES['PROFESOR']:       # L√≠nea 805: Si es Profesor...
                flujo_global_df = flujo_profesor(flujo_global_df, user_id) # L√≠nea 806: Llama al men√∫ del Profesor.
            elif rol == ROLES['ESTUDIANTE']:     # L√≠nea 807: Si es Estudiante...
                flujo_global_df = flujo_estudiante(flujo_global_df, user_id) # L√≠nea 808: Llama al men√∫ del Estudiante.
            
            # 4. Despu√©s de cada sesi√≥n (break en el men√∫), el bucle vuelve a pedir login.
            
        except KeyboardInterrupt:                # L√≠nea 812: Captura si el usuario presiona Ctrl+C.
            print("\nInterrupci√≥n detectada. Guardando datos y saliendo...") # L√≠nea 813: Mensaje.
            guardar_datos(flujo_global_df)       # L√≠nea 814: Guarda los datos antes de salir.
            break                                # L√≠nea 815: Rompe el bucle.
            
        except Exception as e:                   # L√≠nea 817: Captura cualquier otro error no esperado.
            print(f"\nOcurri√≥ un error inesperado en el sistema: {e}") # L√≠nea 818: Imprime el error.
            print("Se ha cerrado la sesi√≥n para evitar problemas.") # L√≠nea 819: Mensaje de seguridad.
            # Se permite que el bucle contin√∫e para que el usuario pueda intentar un nuevo login.
            
    # --- 5. Cierre Final ---
    print("\nPrograma terminado.")               # L√≠nea 823: Mensaje de fin.

if __name__ == "__main__":                       # L√≠nea 825: Condici√≥n que se cumple solo si el archivo se ejecuta directamente.
    # Esta es la l√≠nea de c√≥digo que inicia todo el proceso.
    main()                                       # L√≠nea 827: Llama a la funci√≥n principal 'main()' para empezar.
# Fin del archivo. Total de l√≠neas: 830.